// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MESSAGES_TORCHCRAFT_FBS_H_
#define FLATBUFFERS_GENERATED_MESSAGES_TORCHCRAFT_FBS_H_

#include "flatbuffers.h"

namespace torchcraft {
namespace fbs {

struct Vec2;

struct Command;
struct CommandT;

struct HandshakeClient;
struct HandshakeClientT;

struct HandshakeServer;
struct HandshakeServerT;

struct Commands;
struct CommandsT;

struct Frame;
struct FrameT;

struct PlayerLeft;
struct PlayerLeftT;

struct EndGame;
struct EndGameT;

struct Error;
struct ErrorT;

struct Message;
struct MessageT;

enum class Any : uint8_t {
  NONE = 0,
  HandshakeClient = 1,
  Commands = 2,
  HandshakeServer = 3,
  Frame = 4,
  PlayerLeft = 5,
  EndGame = 6,
  Error = 7,
  MIN = NONE,
  MAX = Error
};

inline const char **EnumNamesAny() {
  static const char *names[] = { "NONE", "HandshakeClient", "Commands", "HandshakeServer", "Frame", "PlayerLeft", "EndGame", "Error", nullptr };
  return names;
}

inline const char *EnumNameAny(Any e) { return EnumNamesAny()[static_cast<int>(e)]; }

template<typename T> struct AnyTraits {
  static const Any enum_value = Any::NONE;
};

template<> struct AnyTraits<HandshakeClient> {
  static const Any enum_value = Any::HandshakeClient;
};

template<> struct AnyTraits<Commands> {
  static const Any enum_value = Any::Commands;
};

template<> struct AnyTraits<HandshakeServer> {
  static const Any enum_value = Any::HandshakeServer;
};

template<> struct AnyTraits<Frame> {
  static const Any enum_value = Any::Frame;
};

template<> struct AnyTraits<PlayerLeft> {
  static const Any enum_value = Any::PlayerLeft;
};

template<> struct AnyTraits<EndGame> {
  static const Any enum_value = Any::EndGame;
};

template<> struct AnyTraits<Error> {
  static const Any enum_value = Any::Error;
};

struct AnyUnion {
  Any type;

  flatbuffers::NativeTable *table;
  AnyUnion() : type(Any::NONE), table(nullptr) {}
  AnyUnion(const AnyUnion &);
  AnyUnion &operator=(const AnyUnion &);
  ~AnyUnion() { Reset(); }
  void Reset();

  template <typename T>
  void Set(T&& value) {
    Reset();
    type = AnyTraits<typename T::TableType>::enum_value;
    if (type != Any::NONE) {
      table = new T(std::forward<T>(value));
    }
  }

  static flatbuffers::NativeTable *UnPack(const void *union_obj, Any type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *rehasher = nullptr) const;

  HandshakeClientT *AsHandshakeClient() { return type == Any::HandshakeClient ? reinterpret_cast<HandshakeClientT *>(table) : nullptr; }
  CommandsT *AsCommands() { return type == Any::Commands ? reinterpret_cast<CommandsT *>(table) : nullptr; }
  HandshakeServerT *AsHandshakeServer() { return type == Any::HandshakeServer ? reinterpret_cast<HandshakeServerT *>(table) : nullptr; }
  FrameT *AsFrame() { return type == Any::Frame ? reinterpret_cast<FrameT *>(table) : nullptr; }
  PlayerLeftT *AsPlayerLeft() { return type == Any::PlayerLeft ? reinterpret_cast<PlayerLeftT *>(table) : nullptr; }
  EndGameT *AsEndGame() { return type == Any::EndGame ? reinterpret_cast<EndGameT *>(table) : nullptr; }
  ErrorT *AsError() { return type == Any::Error ? reinterpret_cast<ErrorT *>(table) : nullptr; }
};

inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, Any type);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Vec2() { memset(this, 0, sizeof(Vec2)); }
  Vec2(const Vec2 &_o) { memcpy(this, &_o, sizeof(Vec2)); }
  Vec2(int32_t _x, int32_t _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  int32_t x() const { return flatbuffers::EndianScalar(x_); }
  void mutate_x(int32_t _x) { flatbuffers::WriteScalar(&x_, _x); }
  int32_t y() const { return flatbuffers::EndianScalar(y_); }
  void mutate_y(int32_t _y) { flatbuffers::WriteScalar(&y_, _y); }
};
STRUCT_END(Vec2, 8);

struct CommandT : public flatbuffers::NativeTable {
  typedef Command TableType;
  int32_t code;
  std::vector<int32_t> args;
  std::string str;
  CommandT()
    : code(0) {}
};

struct Command FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommandT NativeTableType;
  enum {
    VT_CODE = 4,
    VT_ARGS = 6,
    VT_STR = 8
  };
  int32_t code() const { return GetField<int32_t>(VT_CODE, 0); }
  bool mutate_code(int32_t _code) { return SetField(VT_CODE, _code); }
  const flatbuffers::Vector<int32_t> *args() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ARGS); }
  flatbuffers::Vector<int32_t> *mutable_args() { return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ARGS); }
  const flatbuffers::String *str() const { return GetPointer<const flatbuffers::String *>(VT_STR); }
  flatbuffers::String *mutable_str() { return GetPointer<flatbuffers::String *>(VT_STR); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ARGS) &&
           verifier.Verify(args()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_STR) &&
           verifier.Verify(str()) &&
           verifier.EndTable();
  }
  CommandT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<Command> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int32_t code) { fbb_.AddElement<int32_t>(Command::VT_CODE, code, 0); }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<int32_t>> args) { fbb_.AddOffset(Command::VT_ARGS, args); }
  void add_str(flatbuffers::Offset<flatbuffers::String> str) { fbb_.AddOffset(Command::VT_STR, str); }
  CommandBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CommandBuilder &operator=(const CommandBuilder &);
  flatbuffers::Offset<Command> Finish() {
    auto o = flatbuffers::Offset<Command>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Command> CreateCommand(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> args = 0,
    flatbuffers::Offset<flatbuffers::String> str = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_str(str);
  builder_.add_args(args);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Command> CreateCommandDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    const std::vector<int32_t> *args = nullptr,
    const char *str = nullptr) {
  return CreateCommand(_fbb, code, args ? _fbb.CreateVector<int32_t>(*args) : 0, str ? _fbb.CreateString(str) : 0);
}

inline flatbuffers::Offset<Command> CreateCommand(flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct HandshakeClientT : public flatbuffers::NativeTable {
  typedef HandshakeClient TableType;
  int32_t protocol;
  std::string map;
  std::unique_ptr<Vec2> window_size;
  std::unique_ptr<Vec2> window_pos;
  bool micro_mode;
  HandshakeClientT()
    : protocol(0),
      micro_mode(false) {}
};

struct HandshakeClient FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeClientT NativeTableType;
  enum {
    VT_PROTOCOL = 4,
    VT_MAP = 6,
    VT_WINDOW_SIZE = 8,
    VT_WINDOW_POS = 10,
    VT_MICRO_MODE = 12
  };
  int32_t protocol() const { return GetField<int32_t>(VT_PROTOCOL, 0); }
  bool mutate_protocol(int32_t _protocol) { return SetField(VT_PROTOCOL, _protocol); }
  const flatbuffers::String *map() const { return GetPointer<const flatbuffers::String *>(VT_MAP); }
  flatbuffers::String *mutable_map() { return GetPointer<flatbuffers::String *>(VT_MAP); }
  const Vec2 *window_size() const { return GetStruct<const Vec2 *>(VT_WINDOW_SIZE); }
  Vec2 *mutable_window_size() { return GetStruct<Vec2 *>(VT_WINDOW_SIZE); }
  const Vec2 *window_pos() const { return GetStruct<const Vec2 *>(VT_WINDOW_POS); }
  Vec2 *mutable_window_pos() { return GetStruct<Vec2 *>(VT_WINDOW_POS); }
  bool micro_mode() const { return GetField<uint8_t>(VT_MICRO_MODE, 0) != 0; }
  bool mutate_micro_mode(bool _micro_mode) { return SetField(VT_MICRO_MODE, static_cast<uint8_t>(_micro_mode)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PROTOCOL) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MAP) &&
           verifier.Verify(map()) &&
           VerifyField<Vec2>(verifier, VT_WINDOW_SIZE) &&
           VerifyField<Vec2>(verifier, VT_WINDOW_POS) &&
           VerifyField<uint8_t>(verifier, VT_MICRO_MODE) &&
           verifier.EndTable();
  }
  HandshakeClientT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<HandshakeClient> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeClientT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HandshakeClientBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol(int32_t protocol) { fbb_.AddElement<int32_t>(HandshakeClient::VT_PROTOCOL, protocol, 0); }
  void add_map(flatbuffers::Offset<flatbuffers::String> map) { fbb_.AddOffset(HandshakeClient::VT_MAP, map); }
  void add_window_size(const Vec2 *window_size) { fbb_.AddStruct(HandshakeClient::VT_WINDOW_SIZE, window_size); }
  void add_window_pos(const Vec2 *window_pos) { fbb_.AddStruct(HandshakeClient::VT_WINDOW_POS, window_pos); }
  void add_micro_mode(bool micro_mode) { fbb_.AddElement<uint8_t>(HandshakeClient::VT_MICRO_MODE, static_cast<uint8_t>(micro_mode), 0); }
  HandshakeClientBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  HandshakeClientBuilder &operator=(const HandshakeClientBuilder &);
  flatbuffers::Offset<HandshakeClient> Finish() {
    auto o = flatbuffers::Offset<HandshakeClient>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<HandshakeClient> CreateHandshakeClient(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t protocol = 0,
    flatbuffers::Offset<flatbuffers::String> map = 0,
    const Vec2 *window_size = 0,
    const Vec2 *window_pos = 0,
    bool micro_mode = false) {
  HandshakeClientBuilder builder_(_fbb);
  builder_.add_window_pos(window_pos);
  builder_.add_window_size(window_size);
  builder_.add_map(map);
  builder_.add_protocol(protocol);
  builder_.add_micro_mode(micro_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandshakeClient> CreateHandshakeClientDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t protocol = 0,
    const char *map = nullptr,
    const Vec2 *window_size = 0,
    const Vec2 *window_pos = 0,
    bool micro_mode = false) {
  return CreateHandshakeClient(_fbb, protocol, map ? _fbb.CreateString(map) : 0, window_size, window_pos, micro_mode);
}

inline flatbuffers::Offset<HandshakeClient> CreateHandshakeClient(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeClientT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct HandshakeServerT : public flatbuffers::NativeTable {
  typedef HandshakeServer TableType;
  int32_t lag_frames;
  std::unique_ptr<Vec2> map_size;
  std::vector<uint8_t> ground_height_data;
  std::vector<uint8_t> walkable_data;
  std::string map_name;
  bool is_replay;
  int32_t player_id;
  int32_t neutral_id;
  int32_t battle_frame_count;
  std::vector<uint8_t> buildable_data;
  std::vector<Vec2> start_locations;
  HandshakeServerT()
    : lag_frames(0),
      is_replay(false),
      player_id(0),
      neutral_id(0),
      battle_frame_count(0) {}
};

struct HandshakeServer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeServerT NativeTableType;
  enum {
    VT_LAG_FRAMES = 4,
    VT_MAP_SIZE = 6,
    VT_GROUND_HEIGHT_DATA = 8,
    VT_WALKABLE_DATA = 10,
    VT_MAP_NAME = 12,
    VT_IS_REPLAY = 14,
    VT_PLAYER_ID = 16,
    VT_NEUTRAL_ID = 18,
    VT_BATTLE_FRAME_COUNT = 20,
    VT_BUILDABLE_DATA = 22,
    VT_START_LOCATIONS = 24
  };
  int32_t lag_frames() const { return GetField<int32_t>(VT_LAG_FRAMES, 0); }
  bool mutate_lag_frames(int32_t _lag_frames) { return SetField(VT_LAG_FRAMES, _lag_frames); }
  const Vec2 *map_size() const { return GetStruct<const Vec2 *>(VT_MAP_SIZE); }
  Vec2 *mutable_map_size() { return GetStruct<Vec2 *>(VT_MAP_SIZE); }
  const flatbuffers::Vector<uint8_t> *ground_height_data() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_GROUND_HEIGHT_DATA); }
  flatbuffers::Vector<uint8_t> *mutable_ground_height_data() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_GROUND_HEIGHT_DATA); }
  const flatbuffers::Vector<uint8_t> *walkable_data() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_WALKABLE_DATA); }
  flatbuffers::Vector<uint8_t> *mutable_walkable_data() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_WALKABLE_DATA); }
  const flatbuffers::String *map_name() const { return GetPointer<const flatbuffers::String *>(VT_MAP_NAME); }
  flatbuffers::String *mutable_map_name() { return GetPointer<flatbuffers::String *>(VT_MAP_NAME); }
  bool is_replay() const { return GetField<uint8_t>(VT_IS_REPLAY, 0) != 0; }
  bool mutate_is_replay(bool _is_replay) { return SetField(VT_IS_REPLAY, static_cast<uint8_t>(_is_replay)); }
  int32_t player_id() const { return GetField<int32_t>(VT_PLAYER_ID, 0); }
  bool mutate_player_id(int32_t _player_id) { return SetField(VT_PLAYER_ID, _player_id); }
  int32_t neutral_id() const { return GetField<int32_t>(VT_NEUTRAL_ID, 0); }
  bool mutate_neutral_id(int32_t _neutral_id) { return SetField(VT_NEUTRAL_ID, _neutral_id); }
  int32_t battle_frame_count() const { return GetField<int32_t>(VT_BATTLE_FRAME_COUNT, 0); }
  bool mutate_battle_frame_count(int32_t _battle_frame_count) { return SetField(VT_BATTLE_FRAME_COUNT, _battle_frame_count); }
  const flatbuffers::Vector<uint8_t> *buildable_data() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUILDABLE_DATA); }
  flatbuffers::Vector<uint8_t> *mutable_buildable_data() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BUILDABLE_DATA); }
  const flatbuffers::Vector<const Vec2 *> *start_locations() const { return GetPointer<const flatbuffers::Vector<const Vec2 *> *>(VT_START_LOCATIONS); }
  flatbuffers::Vector<const Vec2 *> *mutable_start_locations() { return GetPointer<flatbuffers::Vector<const Vec2 *> *>(VT_START_LOCATIONS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LAG_FRAMES) &&
           VerifyField<Vec2>(verifier, VT_MAP_SIZE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_GROUND_HEIGHT_DATA) &&
           verifier.Verify(ground_height_data()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_WALKABLE_DATA) &&
           verifier.Verify(walkable_data()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MAP_NAME) &&
           verifier.Verify(map_name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_REPLAY) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_ID) &&
           VerifyField<int32_t>(verifier, VT_NEUTRAL_ID) &&
           VerifyField<int32_t>(verifier, VT_BATTLE_FRAME_COUNT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BUILDABLE_DATA) &&
           verifier.Verify(buildable_data()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_START_LOCATIONS) &&
           verifier.Verify(start_locations()) &&
           verifier.EndTable();
  }
  HandshakeServerT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<HandshakeServer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HandshakeServerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lag_frames(int32_t lag_frames) { fbb_.AddElement<int32_t>(HandshakeServer::VT_LAG_FRAMES, lag_frames, 0); }
  void add_map_size(const Vec2 *map_size) { fbb_.AddStruct(HandshakeServer::VT_MAP_SIZE, map_size); }
  void add_ground_height_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ground_height_data) { fbb_.AddOffset(HandshakeServer::VT_GROUND_HEIGHT_DATA, ground_height_data); }
  void add_walkable_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> walkable_data) { fbb_.AddOffset(HandshakeServer::VT_WALKABLE_DATA, walkable_data); }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) { fbb_.AddOffset(HandshakeServer::VT_MAP_NAME, map_name); }
  void add_is_replay(bool is_replay) { fbb_.AddElement<uint8_t>(HandshakeServer::VT_IS_REPLAY, static_cast<uint8_t>(is_replay), 0); }
  void add_player_id(int32_t player_id) { fbb_.AddElement<int32_t>(HandshakeServer::VT_PLAYER_ID, player_id, 0); }
  void add_neutral_id(int32_t neutral_id) { fbb_.AddElement<int32_t>(HandshakeServer::VT_NEUTRAL_ID, neutral_id, 0); }
  void add_battle_frame_count(int32_t battle_frame_count) { fbb_.AddElement<int32_t>(HandshakeServer::VT_BATTLE_FRAME_COUNT, battle_frame_count, 0); }
  void add_buildable_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buildable_data) { fbb_.AddOffset(HandshakeServer::VT_BUILDABLE_DATA, buildable_data); }
  void add_start_locations(flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> start_locations) { fbb_.AddOffset(HandshakeServer::VT_START_LOCATIONS, start_locations); }
  HandshakeServerBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  HandshakeServerBuilder &operator=(const HandshakeServerBuilder &);
  flatbuffers::Offset<HandshakeServer> Finish() {
    auto o = flatbuffers::Offset<HandshakeServer>(fbb_.EndTable(start_, 11));
    return o;
  }
};

inline flatbuffers::Offset<HandshakeServer> CreateHandshakeServer(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lag_frames = 0,
    const Vec2 *map_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ground_height_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> walkable_data = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    bool is_replay = false,
    int32_t player_id = 0,
    int32_t neutral_id = 0,
    int32_t battle_frame_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buildable_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> start_locations = 0) {
  HandshakeServerBuilder builder_(_fbb);
  builder_.add_start_locations(start_locations);
  builder_.add_buildable_data(buildable_data);
  builder_.add_battle_frame_count(battle_frame_count);
  builder_.add_neutral_id(neutral_id);
  builder_.add_player_id(player_id);
  builder_.add_map_name(map_name);
  builder_.add_walkable_data(walkable_data);
  builder_.add_ground_height_data(ground_height_data);
  builder_.add_map_size(map_size);
  builder_.add_lag_frames(lag_frames);
  builder_.add_is_replay(is_replay);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandshakeServer> CreateHandshakeServerDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lag_frames = 0,
    const Vec2 *map_size = 0,
    const std::vector<uint8_t> *ground_height_data = nullptr,
    const std::vector<uint8_t> *walkable_data = nullptr,
    const char *map_name = nullptr,
    bool is_replay = false,
    int32_t player_id = 0,
    int32_t neutral_id = 0,
    int32_t battle_frame_count = 0,
    const std::vector<uint8_t> *buildable_data = nullptr,
    const std::vector<const Vec2 *> *start_locations = nullptr) {
  return CreateHandshakeServer(_fbb, lag_frames, map_size, ground_height_data ? _fbb.CreateVector<uint8_t>(*ground_height_data) : 0, walkable_data ? _fbb.CreateVector<uint8_t>(*walkable_data) : 0, map_name ? _fbb.CreateString(map_name) : 0, is_replay, player_id, neutral_id, battle_frame_count, buildable_data ? _fbb.CreateVector<uint8_t>(*buildable_data) : 0, start_locations ? _fbb.CreateVector<const Vec2 *>(*start_locations) : 0);
}

inline flatbuffers::Offset<HandshakeServer> CreateHandshakeServer(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeServerT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct CommandsT : public flatbuffers::NativeTable {
  typedef Commands TableType;
  std::vector<std::unique_ptr<CommandT>> commands;
  CommandsT() {}
};

struct Commands FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommandsT NativeTableType;
  enum {
    VT_COMMANDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Command>> *commands() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Command>> *>(VT_COMMANDS); }
  flatbuffers::Vector<flatbuffers::Offset<Command>> *mutable_commands() { return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Command>> *>(VT_COMMANDS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMANDS) &&
           verifier.Verify(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           verifier.EndTable();
  }
  CommandsT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<Commands> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CommandsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CommandsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Command>>> commands) { fbb_.AddOffset(Commands::VT_COMMANDS, commands); }
  CommandsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CommandsBuilder &operator=(const CommandsBuilder &);
  flatbuffers::Offset<Commands> Finish() {
    auto o = flatbuffers::Offset<Commands>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Commands> CreateCommands(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Command>>> commands = 0) {
  CommandsBuilder builder_(_fbb);
  builder_.add_commands(commands);
  return builder_.Finish();
}

inline flatbuffers::Offset<Commands> CreateCommandsDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Command>> *commands = nullptr) {
  return CreateCommands(_fbb, commands ? _fbb.CreateVector<flatbuffers::Offset<Command>>(*commands) : 0);
}

inline flatbuffers::Offset<Commands> CreateCommands(flatbuffers::FlatBufferBuilder &_fbb, const CommandsT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct FrameT : public flatbuffers::NativeTable {
  typedef Frame TableType;
  std::vector<uint8_t> data;
  std::vector<int32_t> deaths;
  int32_t frame_from_bwapi;
  int32_t battle_frame_count;
  std::string img_mode;
  std::unique_ptr<Vec2> screen_position;
  std::vector<uint8_t> visibility;
  std::unique_ptr<Vec2> visibility_size;
  std::vector<uint8_t> img_data;
  std::unique_ptr<Vec2> img_size;
  FrameT()
    : frame_from_bwapi(0),
      battle_frame_count(0) {}
};

struct Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameT NativeTableType;
  enum {
    VT_DATA = 4,
    VT_DEATHS = 6,
    VT_FRAME_FROM_BWAPI = 8,
    VT_BATTLE_FRAME_COUNT = 10,
    VT_IMG_MODE = 12,
    VT_SCREEN_POSITION = 14,
    VT_VISIBILITY = 16,
    VT_VISIBILITY_SIZE = 18,
    VT_IMG_DATA = 20,
    VT_IMG_SIZE = 22
  };
  const flatbuffers::Vector<uint8_t> *data() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA); }
  flatbuffers::Vector<uint8_t> *mutable_data() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA); }
  const flatbuffers::Vector<int32_t> *deaths() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DEATHS); }
  flatbuffers::Vector<int32_t> *mutable_deaths() { return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DEATHS); }
  int32_t frame_from_bwapi() const { return GetField<int32_t>(VT_FRAME_FROM_BWAPI, 0); }
  bool mutate_frame_from_bwapi(int32_t _frame_from_bwapi) { return SetField(VT_FRAME_FROM_BWAPI, _frame_from_bwapi); }
  int32_t battle_frame_count() const { return GetField<int32_t>(VT_BATTLE_FRAME_COUNT, 0); }
  bool mutate_battle_frame_count(int32_t _battle_frame_count) { return SetField(VT_BATTLE_FRAME_COUNT, _battle_frame_count); }
  const flatbuffers::String *img_mode() const { return GetPointer<const flatbuffers::String *>(VT_IMG_MODE); }
  flatbuffers::String *mutable_img_mode() { return GetPointer<flatbuffers::String *>(VT_IMG_MODE); }
  const Vec2 *screen_position() const { return GetStruct<const Vec2 *>(VT_SCREEN_POSITION); }
  Vec2 *mutable_screen_position() { return GetStruct<Vec2 *>(VT_SCREEN_POSITION); }
  const flatbuffers::Vector<uint8_t> *visibility() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VISIBILITY); }
  flatbuffers::Vector<uint8_t> *mutable_visibility() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_VISIBILITY); }
  const Vec2 *visibility_size() const { return GetStruct<const Vec2 *>(VT_VISIBILITY_SIZE); }
  Vec2 *mutable_visibility_size() { return GetStruct<Vec2 *>(VT_VISIBILITY_SIZE); }
  const flatbuffers::Vector<uint8_t> *img_data() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_IMG_DATA); }
  flatbuffers::Vector<uint8_t> *mutable_img_data() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_IMG_DATA); }
  const Vec2 *img_size() const { return GetStruct<const Vec2 *>(VT_IMG_SIZE); }
  Vec2 *mutable_img_size() { return GetStruct<Vec2 *>(VT_IMG_SIZE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEATHS) &&
           verifier.Verify(deaths()) &&
           VerifyField<int32_t>(verifier, VT_FRAME_FROM_BWAPI) &&
           VerifyField<int32_t>(verifier, VT_BATTLE_FRAME_COUNT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_IMG_MODE) &&
           verifier.Verify(img_mode()) &&
           VerifyField<Vec2>(verifier, VT_SCREEN_POSITION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VISIBILITY) &&
           verifier.Verify(visibility()) &&
           VerifyField<Vec2>(verifier, VT_VISIBILITY_SIZE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_IMG_DATA) &&
           verifier.Verify(img_data()) &&
           VerifyField<Vec2>(verifier, VT_IMG_SIZE) &&
           verifier.EndTable();
  }
  FrameT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<Frame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) { fbb_.AddOffset(Frame::VT_DATA, data); }
  void add_deaths(flatbuffers::Offset<flatbuffers::Vector<int32_t>> deaths) { fbb_.AddOffset(Frame::VT_DEATHS, deaths); }
  void add_frame_from_bwapi(int32_t frame_from_bwapi) { fbb_.AddElement<int32_t>(Frame::VT_FRAME_FROM_BWAPI, frame_from_bwapi, 0); }
  void add_battle_frame_count(int32_t battle_frame_count) { fbb_.AddElement<int32_t>(Frame::VT_BATTLE_FRAME_COUNT, battle_frame_count, 0); }
  void add_img_mode(flatbuffers::Offset<flatbuffers::String> img_mode) { fbb_.AddOffset(Frame::VT_IMG_MODE, img_mode); }
  void add_screen_position(const Vec2 *screen_position) { fbb_.AddStruct(Frame::VT_SCREEN_POSITION, screen_position); }
  void add_visibility(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> visibility) { fbb_.AddOffset(Frame::VT_VISIBILITY, visibility); }
  void add_visibility_size(const Vec2 *visibility_size) { fbb_.AddStruct(Frame::VT_VISIBILITY_SIZE, visibility_size); }
  void add_img_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> img_data) { fbb_.AddOffset(Frame::VT_IMG_DATA, img_data); }
  void add_img_size(const Vec2 *img_size) { fbb_.AddStruct(Frame::VT_IMG_SIZE, img_size); }
  FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FrameBuilder &operator=(const FrameBuilder &);
  flatbuffers::Offset<Frame> Finish() {
    auto o = flatbuffers::Offset<Frame>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<Frame> CreateFrame(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> deaths = 0,
    int32_t frame_from_bwapi = 0,
    int32_t battle_frame_count = 0,
    flatbuffers::Offset<flatbuffers::String> img_mode = 0,
    const Vec2 *screen_position = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> visibility = 0,
    const Vec2 *visibility_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> img_data = 0,
    const Vec2 *img_size = 0) {
  FrameBuilder builder_(_fbb);
  builder_.add_img_size(img_size);
  builder_.add_img_data(img_data);
  builder_.add_visibility_size(visibility_size);
  builder_.add_visibility(visibility);
  builder_.add_screen_position(screen_position);
  builder_.add_img_mode(img_mode);
  builder_.add_battle_frame_count(battle_frame_count);
  builder_.add_frame_from_bwapi(frame_from_bwapi);
  builder_.add_deaths(deaths);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Frame> CreateFrameDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr,
    const std::vector<int32_t> *deaths = nullptr,
    int32_t frame_from_bwapi = 0,
    int32_t battle_frame_count = 0,
    const char *img_mode = nullptr,
    const Vec2 *screen_position = 0,
    const std::vector<uint8_t> *visibility = nullptr,
    const Vec2 *visibility_size = 0,
    const std::vector<uint8_t> *img_data = nullptr,
    const Vec2 *img_size = 0) {
  return CreateFrame(_fbb, data ? _fbb.CreateVector<uint8_t>(*data) : 0, deaths ? _fbb.CreateVector<int32_t>(*deaths) : 0, frame_from_bwapi, battle_frame_count, img_mode ? _fbb.CreateString(img_mode) : 0, screen_position, visibility ? _fbb.CreateVector<uint8_t>(*visibility) : 0, visibility_size, img_data ? _fbb.CreateVector<uint8_t>(*img_data) : 0, img_size);
}

inline flatbuffers::Offset<Frame> CreateFrame(flatbuffers::FlatBufferBuilder &_fbb, const FrameT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct PlayerLeftT : public flatbuffers::NativeTable {
  typedef PlayerLeft TableType;
  std::string player_left;
  PlayerLeftT() {}
};

struct PlayerLeft FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerLeftT NativeTableType;
  enum {
    VT_PLAYER_LEFT = 4
  };
  const flatbuffers::String *player_left() const { return GetPointer<const flatbuffers::String *>(VT_PLAYER_LEFT); }
  flatbuffers::String *mutable_player_left() { return GetPointer<flatbuffers::String *>(VT_PLAYER_LEFT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLAYER_LEFT) &&
           verifier.Verify(player_left()) &&
           verifier.EndTable();
  }
  PlayerLeftT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<PlayerLeft> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerLeftT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerLeftBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_left(flatbuffers::Offset<flatbuffers::String> player_left) { fbb_.AddOffset(PlayerLeft::VT_PLAYER_LEFT, player_left); }
  PlayerLeftBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PlayerLeftBuilder &operator=(const PlayerLeftBuilder &);
  flatbuffers::Offset<PlayerLeft> Finish() {
    auto o = flatbuffers::Offset<PlayerLeft>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<PlayerLeft> CreatePlayerLeft(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> player_left = 0) {
  PlayerLeftBuilder builder_(_fbb);
  builder_.add_player_left(player_left);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerLeft> CreatePlayerLeftDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *player_left = nullptr) {
  return CreatePlayerLeft(_fbb, player_left ? _fbb.CreateString(player_left) : 0);
}

inline flatbuffers::Offset<PlayerLeft> CreatePlayerLeft(flatbuffers::FlatBufferBuilder &_fbb, const PlayerLeftT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct EndGameT : public flatbuffers::NativeTable {
  typedef EndGame TableType;
  std::vector<uint8_t> frame;
  bool game_won;
  EndGameT()
    : game_won(false) {}
};

struct EndGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndGameT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_GAME_WON = 6
  };
  const flatbuffers::Vector<uint8_t> *frame() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FRAME); }
  flatbuffers::Vector<uint8_t> *mutable_frame() { return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_FRAME); }
  bool game_won() const { return GetField<uint8_t>(VT_GAME_WON, 0) != 0; }
  bool mutate_game_won(bool _game_won) { return SetField(VT_GAME_WON, static_cast<uint8_t>(_game_won)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FRAME) &&
           verifier.Verify(frame()) &&
           VerifyField<uint8_t>(verifier, VT_GAME_WON) &&
           verifier.EndTable();
  }
  EndGameT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<EndGame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndGameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EndGameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> frame) { fbb_.AddOffset(EndGame::VT_FRAME, frame); }
  void add_game_won(bool game_won) { fbb_.AddElement<uint8_t>(EndGame::VT_GAME_WON, static_cast<uint8_t>(game_won), 0); }
  EndGameBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EndGameBuilder &operator=(const EndGameBuilder &);
  flatbuffers::Offset<EndGame> Finish() {
    auto o = flatbuffers::Offset<EndGame>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<EndGame> CreateEndGame(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> frame = 0,
    bool game_won = false) {
  EndGameBuilder builder_(_fbb);
  builder_.add_frame(frame);
  builder_.add_game_won(game_won);
  return builder_.Finish();
}

inline flatbuffers::Offset<EndGame> CreateEndGameDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *frame = nullptr,
    bool game_won = false) {
  return CreateEndGame(_fbb, frame ? _fbb.CreateVector<uint8_t>(*frame) : 0, game_won);
}

inline flatbuffers::Offset<EndGame> CreateEndGame(flatbuffers::FlatBufferBuilder &_fbb, const EndGameT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct ErrorT : public flatbuffers::NativeTable {
  typedef Error TableType;
  std::string message;
  ErrorT() {}
};

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorT NativeTableType;
  enum {
    VT_MESSAGE = 4
  };
  const flatbuffers::String *message() const { return GetPointer<const flatbuffers::String *>(VT_MESSAGE); }
  flatbuffers::String *mutable_message() { return GetPointer<flatbuffers::String *>(VT_MESSAGE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<Error> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) { fbb_.AddOffset(Error::VT_MESSAGE, message); }
  ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ErrorBuilder &operator=(const ErrorBuilder &);
  flatbuffers::Offset<Error> Finish() {
    auto o = flatbuffers::Offset<Error>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  return CreateError(_fbb, message ? _fbb.CreateString(message) : 0);
}

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

struct MessageT : public flatbuffers::NativeTable {
  typedef Message TableType;
  AnyUnion msg;
  std::string uid;
  MessageT() {}
};

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageT NativeTableType;
  enum {
    VT_MSG_TYPE = 4,
    VT_MSG = 6,
    VT_UID = 8
  };
  Any msg_type() const { return static_cast<Any>(GetField<uint8_t>(VT_MSG_TYPE, 0)); }
  bool mutate_msg_type(Any _msg_type) { return SetField(VT_MSG_TYPE, static_cast<uint8_t>(_msg_type)); }
  const void *msg() const { return GetPointer<const void *>(VT_MSG); }
  void *mutable_msg() { return GetPointer<void *>(VT_MSG); }
  const flatbuffers::String *uid() const { return GetPointer<const flatbuffers::String *>(VT_UID); }
  flatbuffers::String *mutable_uid() { return GetPointer<flatbuffers::String *>(VT_UID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MSG) &&
           VerifyAny(verifier, msg(), msg_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UID) &&
           verifier.Verify(uid()) &&
           verifier.EndTable();
  }
  MessageT *UnPack(const flatbuffers::resolver_function_t *resolver = nullptr) const;
  static flatbuffers::Offset<Message> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(Any msg_type) { fbb_.AddElement<uint8_t>(Message::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0); }
  void add_msg(flatbuffers::Offset<void> msg) { fbb_.AddOffset(Message::VT_MSG, msg); }
  void add_uid(flatbuffers::Offset<flatbuffers::String> uid) { fbb_.AddOffset(Message::VT_UID, uid); }
  MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    auto o = flatbuffers::Offset<Message>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb,
    Any msg_type = Any::NONE,
    flatbuffers::Offset<void> msg = 0,
    flatbuffers::Offset<flatbuffers::String> uid = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_uid(uid);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(flatbuffers::FlatBufferBuilder &_fbb,
    Any msg_type = Any::NONE,
    flatbuffers::Offset<void> msg = 0,
    const char *uid = nullptr) {
  return CreateMessage(_fbb, msg_type, msg, uid ? _fbb.CreateString(uid) : 0);
}

inline flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *rehasher = nullptr);

inline CommandT *Command::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new CommandT();
  { auto _e = code(); _o->code = _e; };
  { auto _e = args(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->args.push_back(_e->Get(_i)); } } };
  { auto _e = str(); if (_e) _o->str = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<Command> Command::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommand(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Command> CreateCommand(flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateCommand(_fbb,
    _o->code,
    _o->args.size() ? _fbb.CreateVector(_o->args) : 0,
    _o->str.size() ? _fbb.CreateString(_o->str) : 0);
}

inline HandshakeClientT *HandshakeClient::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new HandshakeClientT();
  { auto _e = protocol(); _o->protocol = _e; };
  { auto _e = map(); if (_e) _o->map = _e->str(); };
  { auto _e = window_size(); if (_e) _o->window_size = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = window_pos(); if (_e) _o->window_pos = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = micro_mode(); _o->micro_mode = _e; };
  return _o;
}

inline flatbuffers::Offset<HandshakeClient> HandshakeClient::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeClientT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHandshakeClient(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HandshakeClient> CreateHandshakeClient(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeClientT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateHandshakeClient(_fbb,
    _o->protocol,
    _o->map.size() ? _fbb.CreateString(_o->map) : 0,
    _o->window_size ? _o->window_size.get() : 0,
    _o->window_pos ? _o->window_pos.get() : 0,
    _o->micro_mode);
}

inline HandshakeServerT *HandshakeServer::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new HandshakeServerT();
  { auto _e = lag_frames(); _o->lag_frames = _e; };
  { auto _e = map_size(); if (_e) _o->map_size = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = ground_height_data(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ground_height_data.push_back(_e->Get(_i)); } } };
  { auto _e = walkable_data(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->walkable_data.push_back(_e->Get(_i)); } } };
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); };
  { auto _e = is_replay(); _o->is_replay = _e; };
  { auto _e = player_id(); _o->player_id = _e; };
  { auto _e = neutral_id(); _o->neutral_id = _e; };
  { auto _e = battle_frame_count(); _o->battle_frame_count = _e; };
  { auto _e = buildable_data(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buildable_data.push_back(_e->Get(_i)); } } };
  { auto _e = start_locations(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->start_locations.push_back(*_e->Get(_i)); } } };
  return _o;
}

inline flatbuffers::Offset<HandshakeServer> HandshakeServer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHandshakeServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HandshakeServer> CreateHandshakeServer(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeServerT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateHandshakeServer(_fbb,
    _o->lag_frames,
    _o->map_size ? _o->map_size.get() : 0,
    _o->ground_height_data.size() ? _fbb.CreateVector(_o->ground_height_data) : 0,
    _o->walkable_data.size() ? _fbb.CreateVector(_o->walkable_data) : 0,
    _o->map_name.size() ? _fbb.CreateString(_o->map_name) : 0,
    _o->is_replay,
    _o->player_id,
    _o->neutral_id,
    _o->battle_frame_count,
    _o->buildable_data.size() ? _fbb.CreateVector(_o->buildable_data) : 0,
    _o->start_locations.size() ? _fbb.CreateVectorOfStructs(_o->start_locations) : 0);
}

inline CommandsT *Commands::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new CommandsT();
  { auto _e = commands(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->commands.push_back(std::unique_ptr<CommandT>(_e->Get(_i)->UnPack(resolver))); } } };
  return _o;
}

inline flatbuffers::Offset<Commands> Commands::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CommandsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommands(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Commands> CreateCommands(flatbuffers::FlatBufferBuilder &_fbb, const CommandsT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateCommands(_fbb,
    _o->commands.size() ? _fbb.CreateVector<flatbuffers::Offset<Command>>(_o->commands.size(), [&](size_t i) { return CreateCommand(_fbb, _o->commands[i].get(), rehasher); }) : 0);
}

inline FrameT *Frame::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new FrameT();
  { auto _e = data(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data.push_back(_e->Get(_i)); } } };
  { auto _e = deaths(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->deaths.push_back(_e->Get(_i)); } } };
  { auto _e = frame_from_bwapi(); _o->frame_from_bwapi = _e; };
  { auto _e = battle_frame_count(); _o->battle_frame_count = _e; };
  { auto _e = img_mode(); if (_e) _o->img_mode = _e->str(); };
  { auto _e = screen_position(); if (_e) _o->screen_position = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = visibility(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->visibility.push_back(_e->Get(_i)); } } };
  { auto _e = visibility_size(); if (_e) _o->visibility_size = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = img_data(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->img_data.push_back(_e->Get(_i)); } } };
  { auto _e = img_size(); if (_e) _o->img_size = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  return _o;
}

inline flatbuffers::Offset<Frame> Frame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Frame> CreateFrame(flatbuffers::FlatBufferBuilder &_fbb, const FrameT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateFrame(_fbb,
    _o->data.size() ? _fbb.CreateVector(_o->data) : 0,
    _o->deaths.size() ? _fbb.CreateVector(_o->deaths) : 0,
    _o->frame_from_bwapi,
    _o->battle_frame_count,
    _o->img_mode.size() ? _fbb.CreateString(_o->img_mode) : 0,
    _o->screen_position ? _o->screen_position.get() : 0,
    _o->visibility.size() ? _fbb.CreateVector(_o->visibility) : 0,
    _o->visibility_size ? _o->visibility_size.get() : 0,
    _o->img_data.size() ? _fbb.CreateVector(_o->img_data) : 0,
    _o->img_size ? _o->img_size.get() : 0);
}

inline PlayerLeftT *PlayerLeft::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new PlayerLeftT();
  { auto _e = player_left(); if (_e) _o->player_left = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<PlayerLeft> PlayerLeft::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerLeftT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerLeft(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PlayerLeft> CreatePlayerLeft(flatbuffers::FlatBufferBuilder &_fbb, const PlayerLeftT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreatePlayerLeft(_fbb,
    _o->player_left.size() ? _fbb.CreateString(_o->player_left) : 0);
}

inline EndGameT *EndGame::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new EndGameT();
  { auto _e = frame(); if (_e) { for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->frame.push_back(_e->Get(_i)); } } };
  { auto _e = game_won(); _o->game_won = _e; };
  return _o;
}

inline flatbuffers::Offset<EndGame> EndGame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndGameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndGame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndGame> CreateEndGame(flatbuffers::FlatBufferBuilder &_fbb, const EndGameT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateEndGame(_fbb,
    _o->frame.size() ? _fbb.CreateVector(_o->frame) : 0,
    _o->game_won);
}

inline ErrorT *Error::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new ErrorT();
  { auto _e = message(); if (_e) _o->message = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<Error> Error::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateError(_fbb,
    _o->message.size() ? _fbb.CreateString(_o->message) : 0);
}

inline MessageT *Message::UnPack(const flatbuffers::resolver_function_t *resolver) const {
  (void)resolver;
  auto _o = new MessageT();
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.table = AnyUnion::UnPack(_e, msg_type(), resolver); };
  { auto _e = uid(); if (_e) _o->uid = _e->str(); };
  return _o;
}

inline flatbuffers::Offset<Message> Message::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *rehasher) {
  (void)rehasher;
  return CreateMessage(_fbb,
    _o->msg.type,
    _o->msg.Pack(_fbb),
    _o->uid.size() ? _fbb.CreateString(_o->uid) : 0);
}

inline bool VerifyAny(flatbuffers::Verifier &verifier, const void *union_obj, Any type) {
  switch (type) {
    case Any::NONE: return true;
    case Any::HandshakeClient: return verifier.VerifyTable(reinterpret_cast<const HandshakeClient *>(union_obj));
    case Any::Commands: return verifier.VerifyTable(reinterpret_cast<const Commands *>(union_obj));
    case Any::HandshakeServer: return verifier.VerifyTable(reinterpret_cast<const HandshakeServer *>(union_obj));
    case Any::Frame: return verifier.VerifyTable(reinterpret_cast<const Frame *>(union_obj));
    case Any::PlayerLeft: return verifier.VerifyTable(reinterpret_cast<const PlayerLeft *>(union_obj));
    case Any::EndGame: return verifier.VerifyTable(reinterpret_cast<const EndGame *>(union_obj));
    case Any::Error: return verifier.VerifyTable(reinterpret_cast<const Error *>(union_obj));
    default: return false;
  }
}

inline flatbuffers::NativeTable *AnyUnion::UnPack(const void *union_obj, Any type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Any::NONE: return nullptr;
    case Any::HandshakeClient: return reinterpret_cast<const HandshakeClient *>(union_obj)->UnPack(resolver);
    case Any::Commands: return reinterpret_cast<const Commands *>(union_obj)->UnPack(resolver);
    case Any::HandshakeServer: return reinterpret_cast<const HandshakeServer *>(union_obj)->UnPack(resolver);
    case Any::Frame: return reinterpret_cast<const Frame *>(union_obj)->UnPack(resolver);
    case Any::PlayerLeft: return reinterpret_cast<const PlayerLeft *>(union_obj)->UnPack(resolver);
    case Any::EndGame: return reinterpret_cast<const EndGame *>(union_obj)->UnPack(resolver);
    case Any::Error: return reinterpret_cast<const Error *>(union_obj)->UnPack(resolver);
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> AnyUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *rehasher) const {
  switch (type) {
    case Any::NONE: return 0;
    case Any::HandshakeClient: return CreateHandshakeClient(_fbb, reinterpret_cast<const HandshakeClientT *>(table), rehasher).Union();
    case Any::Commands: return CreateCommands(_fbb, reinterpret_cast<const CommandsT *>(table), rehasher).Union();
    case Any::HandshakeServer: return CreateHandshakeServer(_fbb, reinterpret_cast<const HandshakeServerT *>(table), rehasher).Union();
    case Any::Frame: return CreateFrame(_fbb, reinterpret_cast<const FrameT *>(table), rehasher).Union();
    case Any::PlayerLeft: return CreatePlayerLeft(_fbb, reinterpret_cast<const PlayerLeftT *>(table), rehasher).Union();
    case Any::EndGame: return CreateEndGame(_fbb, reinterpret_cast<const EndGameT *>(table), rehasher).Union();
    case Any::Error: return CreateError(_fbb, reinterpret_cast<const ErrorT *>(table), rehasher).Union();
    default: return 0;
  }
}

inline void AnyUnion::Reset() {
  switch (type) {
    case Any::HandshakeClient: delete reinterpret_cast<HandshakeClientT *>(table); break;
    case Any::Commands: delete reinterpret_cast<CommandsT *>(table); break;
    case Any::HandshakeServer: delete reinterpret_cast<HandshakeServerT *>(table); break;
    case Any::Frame: delete reinterpret_cast<FrameT *>(table); break;
    case Any::PlayerLeft: delete reinterpret_cast<PlayerLeftT *>(table); break;
    case Any::EndGame: delete reinterpret_cast<EndGameT *>(table); break;
    case Any::Error: delete reinterpret_cast<ErrorT *>(table); break;
    default: break;
  }
  table = nullptr;
  type = Any::NONE;
}

inline const torchcraft::fbs::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<torchcraft::fbs::Message>(buf);
}

inline Message *GetMutableMessage(void *buf) {
  return flatbuffers::GetMutableRoot<Message>(buf);
}

inline bool VerifyMessageBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<torchcraft::fbs::Message>(nullptr);
}

inline void FinishMessageBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<torchcraft::fbs::Message> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<MessageT> UnPackMessage(const void *buf, const flatbuffers::resolver_function_t *resolver = nullptr) {
  return std::unique_ptr<MessageT>(GetMessage(buf)->UnPack(resolver));
}

}  // namespace fbs
}  // namespace torchcraft

#endif  // FLATBUFFERS_GENERATED_MESSAGES_TORCHCRAFT_FBS_H_
