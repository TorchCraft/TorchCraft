// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FRAME_TORCHCRAFT_FBS_H_
#define FLATBUFFERS_GENERATED_FRAME_TORCHCRAFT_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace torchcraft {
namespace fbs {

struct Map;
struct MapT;

struct Action;
struct ActionT;

struct Resources;
struct ResourcesT;

struct Order;
struct OrderT;

struct UnitCommand;
struct UnitCommandT;

struct Bullet;
struct BulletT;

struct Unit;
struct UnitT;

struct Frame;
struct FrameT;

struct FrameContainer;
struct FrameContainerT;

struct MapT : public flatbuffers::NativeTable {
  typedef Map TableType;
  int32_t height;
  int32_t width;
  std::vector<uint8_t> data;
  MapT()
      : height(0),
        width(0) {
  }
};

struct Map FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapT NativeTableType;
  enum {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_DATA = 8
  };
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  bool mutate_height(int32_t _height) {
    return SetField<int32_t>(VT_HEIGHT, _height, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  bool mutate_width(int32_t _width) {
    return SetField<int32_t>(VT_WIDTH, _width, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
  MapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Map> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Map::VT_HEIGHT, height, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Map::VT_WIDTH, width, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Map::VT_DATA, data);
  }
  explicit MapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapBuilder &operator=(const MapBuilder &);
  flatbuffers::Offset<Map> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Map>(end);
    return o;
  }
};

inline flatbuffers::Offset<Map> CreateMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  MapBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

inline flatbuffers::Offset<Map> CreateMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    const std::vector<uint8_t> *data = nullptr) {
  return torchcraft::fbs::CreateMap(
      _fbb,
      height,
      width,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

flatbuffers::Offset<Map> CreateMap(flatbuffers::FlatBufferBuilder &_fbb, const MapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionT : public flatbuffers::NativeTable {
  typedef Action TableType;
  std::vector<int32_t> action;
  int32_t uid;
  int32_t aid;
  ActionT()
      : uid(0),
        aid(0) {
  }
};

struct Action FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionT NativeTableType;
  enum {
    VT_ACTION = 4,
    VT_UID = 6,
    VT_AID = 8
  };
  const flatbuffers::Vector<int32_t> *action() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ACTION);
  }
  flatbuffers::Vector<int32_t> *mutable_action() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ACTION);
  }
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  bool mutate_uid(int32_t _uid) {
    return SetField<int32_t>(VT_UID, _uid, 0);
  }
  int32_t aid() const {
    return GetField<int32_t>(VT_AID, 0);
  }
  bool mutate_aid(int32_t _aid) {
    return SetField<int32_t>(VT_AID, _aid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.Verify(action()) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyField<int32_t>(verifier, VT_AID) &&
           verifier.EndTable();
  }
  ActionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Action> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(flatbuffers::Offset<flatbuffers::Vector<int32_t>> action) {
    fbb_.AddOffset(Action::VT_ACTION, action);
  }
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(Action::VT_UID, uid, 0);
  }
  void add_aid(int32_t aid) {
    fbb_.AddElement<int32_t>(Action::VT_AID, aid, 0);
  }
  explicit ActionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionBuilder &operator=(const ActionBuilder &);
  flatbuffers::Offset<Action> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Action>(end);
    return o;
  }
};

inline flatbuffers::Offset<Action> CreateAction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> action = 0,
    int32_t uid = 0,
    int32_t aid = 0) {
  ActionBuilder builder_(_fbb);
  builder_.add_aid(aid);
  builder_.add_uid(uid);
  builder_.add_action(action);
  return builder_.Finish();
}

inline flatbuffers::Offset<Action> CreateActionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *action = nullptr,
    int32_t uid = 0,
    int32_t aid = 0) {
  return torchcraft::fbs::CreateAction(
      _fbb,
      action ? _fbb.CreateVector<int32_t>(*action) : 0,
      uid,
      aid);
}

flatbuffers::Offset<Action> CreateAction(flatbuffers::FlatBufferBuilder &_fbb, const ActionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResourcesT : public flatbuffers::NativeTable {
  typedef Resources TableType;
  int32_t ore;
  int32_t gas;
  int32_t used_psi;
  int32_t total_psi;
  int64_t upgrades;
  int64_t upgrades_level;
  int64_t techs;
  ResourcesT()
      : ore(0),
        gas(0),
        used_psi(0),
        total_psi(0),
        upgrades(0),
        upgrades_level(0),
        techs(0) {
  }
};

struct Resources FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResourcesT NativeTableType;
  enum {
    VT_ORE = 4,
    VT_GAS = 6,
    VT_USED_PSI = 8,
    VT_TOTAL_PSI = 10,
    VT_UPGRADES = 12,
    VT_UPGRADES_LEVEL = 14,
    VT_TECHS = 16
  };
  int32_t ore() const {
    return GetField<int32_t>(VT_ORE, 0);
  }
  bool mutate_ore(int32_t _ore) {
    return SetField<int32_t>(VT_ORE, _ore, 0);
  }
  int32_t gas() const {
    return GetField<int32_t>(VT_GAS, 0);
  }
  bool mutate_gas(int32_t _gas) {
    return SetField<int32_t>(VT_GAS, _gas, 0);
  }
  int32_t used_psi() const {
    return GetField<int32_t>(VT_USED_PSI, 0);
  }
  bool mutate_used_psi(int32_t _used_psi) {
    return SetField<int32_t>(VT_USED_PSI, _used_psi, 0);
  }
  int32_t total_psi() const {
    return GetField<int32_t>(VT_TOTAL_PSI, 0);
  }
  bool mutate_total_psi(int32_t _total_psi) {
    return SetField<int32_t>(VT_TOTAL_PSI, _total_psi, 0);
  }
  int64_t upgrades() const {
    return GetField<int64_t>(VT_UPGRADES, 0);
  }
  bool mutate_upgrades(int64_t _upgrades) {
    return SetField<int64_t>(VT_UPGRADES, _upgrades, 0);
  }
  int64_t upgrades_level() const {
    return GetField<int64_t>(VT_UPGRADES_LEVEL, 0);
  }
  bool mutate_upgrades_level(int64_t _upgrades_level) {
    return SetField<int64_t>(VT_UPGRADES_LEVEL, _upgrades_level, 0);
  }
  int64_t techs() const {
    return GetField<int64_t>(VT_TECHS, 0);
  }
  bool mutate_techs(int64_t _techs) {
    return SetField<int64_t>(VT_TECHS, _techs, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ORE) &&
           VerifyField<int32_t>(verifier, VT_GAS) &&
           VerifyField<int32_t>(verifier, VT_USED_PSI) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_PSI) &&
           VerifyField<int64_t>(verifier, VT_UPGRADES) &&
           VerifyField<int64_t>(verifier, VT_UPGRADES_LEVEL) &&
           VerifyField<int64_t>(verifier, VT_TECHS) &&
           verifier.EndTable();
  }
  ResourcesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResourcesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Resources> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResourcesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ore(int32_t ore) {
    fbb_.AddElement<int32_t>(Resources::VT_ORE, ore, 0);
  }
  void add_gas(int32_t gas) {
    fbb_.AddElement<int32_t>(Resources::VT_GAS, gas, 0);
  }
  void add_used_psi(int32_t used_psi) {
    fbb_.AddElement<int32_t>(Resources::VT_USED_PSI, used_psi, 0);
  }
  void add_total_psi(int32_t total_psi) {
    fbb_.AddElement<int32_t>(Resources::VT_TOTAL_PSI, total_psi, 0);
  }
  void add_upgrades(int64_t upgrades) {
    fbb_.AddElement<int64_t>(Resources::VT_UPGRADES, upgrades, 0);
  }
  void add_upgrades_level(int64_t upgrades_level) {
    fbb_.AddElement<int64_t>(Resources::VT_UPGRADES_LEVEL, upgrades_level, 0);
  }
  void add_techs(int64_t techs) {
    fbb_.AddElement<int64_t>(Resources::VT_TECHS, techs, 0);
  }
  explicit ResourcesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourcesBuilder &operator=(const ResourcesBuilder &);
  flatbuffers::Offset<Resources> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resources>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resources> CreateResources(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ore = 0,
    int32_t gas = 0,
    int32_t used_psi = 0,
    int32_t total_psi = 0,
    int64_t upgrades = 0,
    int64_t upgrades_level = 0,
    int64_t techs = 0) {
  ResourcesBuilder builder_(_fbb);
  builder_.add_techs(techs);
  builder_.add_upgrades_level(upgrades_level);
  builder_.add_upgrades(upgrades);
  builder_.add_total_psi(total_psi);
  builder_.add_used_psi(used_psi);
  builder_.add_gas(gas);
  builder_.add_ore(ore);
  return builder_.Finish();
}

flatbuffers::Offset<Resources> CreateResources(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OrderT : public flatbuffers::NativeTable {
  typedef Order TableType;
  int32_t first_frame;
  int32_t type;
  int32_t targetId;
  int32_t targetX;
  int32_t targetY;
  OrderT()
      : first_frame(0),
        type(0),
        targetId(0),
        targetX(0),
        targetY(0) {
  }
};

struct Order FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderT NativeTableType;
  enum {
    VT_FIRST_FRAME = 4,
    VT_TYPE = 6,
    VT_TARGETID = 8,
    VT_TARGETX = 10,
    VT_TARGETY = 12
  };
  int32_t first_frame() const {
    return GetField<int32_t>(VT_FIRST_FRAME, 0);
  }
  bool mutate_first_frame(int32_t _first_frame) {
    return SetField<int32_t>(VT_FIRST_FRAME, _first_frame, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  int32_t targetId() const {
    return GetField<int32_t>(VT_TARGETID, 0);
  }
  bool mutate_targetId(int32_t _targetId) {
    return SetField<int32_t>(VT_TARGETID, _targetId, 0);
  }
  int32_t targetX() const {
    return GetField<int32_t>(VT_TARGETX, 0);
  }
  bool mutate_targetX(int32_t _targetX) {
    return SetField<int32_t>(VT_TARGETX, _targetX, 0);
  }
  int32_t targetY() const {
    return GetField<int32_t>(VT_TARGETY, 0);
  }
  bool mutate_targetY(int32_t _targetY) {
    return SetField<int32_t>(VT_TARGETY, _targetY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FIRST_FRAME) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_TARGETID) &&
           VerifyField<int32_t>(verifier, VT_TARGETX) &&
           VerifyField<int32_t>(verifier, VT_TARGETY) &&
           verifier.EndTable();
  }
  OrderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OrderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Order> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OrderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OrderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_first_frame(int32_t first_frame) {
    fbb_.AddElement<int32_t>(Order::VT_FIRST_FRAME, first_frame, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Order::VT_TYPE, type, 0);
  }
  void add_targetId(int32_t targetId) {
    fbb_.AddElement<int32_t>(Order::VT_TARGETID, targetId, 0);
  }
  void add_targetX(int32_t targetX) {
    fbb_.AddElement<int32_t>(Order::VT_TARGETX, targetX, 0);
  }
  void add_targetY(int32_t targetY) {
    fbb_.AddElement<int32_t>(Order::VT_TARGETY, targetY, 0);
  }
  explicit OrderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderBuilder &operator=(const OrderBuilder &);
  flatbuffers::Offset<Order> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Order>(end);
    return o;
  }
};

inline flatbuffers::Offset<Order> CreateOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t first_frame = 0,
    int32_t type = 0,
    int32_t targetId = 0,
    int32_t targetX = 0,
    int32_t targetY = 0) {
  OrderBuilder builder_(_fbb);
  builder_.add_targetY(targetY);
  builder_.add_targetX(targetX);
  builder_.add_targetId(targetId);
  builder_.add_type(type);
  builder_.add_first_frame(first_frame);
  return builder_.Finish();
}

flatbuffers::Offset<Order> CreateOrder(flatbuffers::FlatBufferBuilder &_fbb, const OrderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnitCommandT : public flatbuffers::NativeTable {
  typedef UnitCommand TableType;
  int32_t farme;
  int32_t type;
  int32_t targetId;
  int32_t targetX;
  int32_t targetY;
  int32_t extra;
  UnitCommandT()
      : farme(0),
        type(0),
        targetId(0),
        targetX(0),
        targetY(0),
        extra(0) {
  }
};

struct UnitCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnitCommandT NativeTableType;
  enum {
    VT_FARME = 4,
    VT_TYPE = 6,
    VT_TARGETID = 8,
    VT_TARGETX = 10,
    VT_TARGETY = 12,
    VT_EXTRA = 14
  };
  int32_t farme() const {
    return GetField<int32_t>(VT_FARME, 0);
  }
  bool mutate_farme(int32_t _farme) {
    return SetField<int32_t>(VT_FARME, _farme, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  int32_t targetId() const {
    return GetField<int32_t>(VT_TARGETID, 0);
  }
  bool mutate_targetId(int32_t _targetId) {
    return SetField<int32_t>(VT_TARGETID, _targetId, 0);
  }
  int32_t targetX() const {
    return GetField<int32_t>(VT_TARGETX, 0);
  }
  bool mutate_targetX(int32_t _targetX) {
    return SetField<int32_t>(VT_TARGETX, _targetX, 0);
  }
  int32_t targetY() const {
    return GetField<int32_t>(VT_TARGETY, 0);
  }
  bool mutate_targetY(int32_t _targetY) {
    return SetField<int32_t>(VT_TARGETY, _targetY, 0);
  }
  int32_t extra() const {
    return GetField<int32_t>(VT_EXTRA, 0);
  }
  bool mutate_extra(int32_t _extra) {
    return SetField<int32_t>(VT_EXTRA, _extra, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FARME) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_TARGETID) &&
           VerifyField<int32_t>(verifier, VT_TARGETX) &&
           VerifyField<int32_t>(verifier, VT_TARGETY) &&
           VerifyField<int32_t>(verifier, VT_EXTRA) &&
           verifier.EndTable();
  }
  UnitCommandT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnitCommandT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnitCommand> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnitCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_farme(int32_t farme) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_FARME, farme, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_TYPE, type, 0);
  }
  void add_targetId(int32_t targetId) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_TARGETID, targetId, 0);
  }
  void add_targetX(int32_t targetX) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_TARGETX, targetX, 0);
  }
  void add_targetY(int32_t targetY) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_TARGETY, targetY, 0);
  }
  void add_extra(int32_t extra) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_EXTRA, extra, 0);
  }
  explicit UnitCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitCommandBuilder &operator=(const UnitCommandBuilder &);
  flatbuffers::Offset<UnitCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnitCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnitCommand> CreateUnitCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t farme = 0,
    int32_t type = 0,
    int32_t targetId = 0,
    int32_t targetX = 0,
    int32_t targetY = 0,
    int32_t extra = 0) {
  UnitCommandBuilder builder_(_fbb);
  builder_.add_extra(extra);
  builder_.add_targetY(targetY);
  builder_.add_targetX(targetX);
  builder_.add_targetId(targetId);
  builder_.add_type(type);
  builder_.add_farme(farme);
  return builder_.Finish();
}

flatbuffers::Offset<UnitCommand> CreateUnitCommand(flatbuffers::FlatBufferBuilder &_fbb, const UnitCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BulletT : public flatbuffers::NativeTable {
  typedef Bullet TableType;
  int32_t type;
  int32_t x;
  int32_t y;
  BulletT()
      : type(0),
        x(0),
        y(0) {
  }
};

struct Bullet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BulletT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_X = 6,
    VT_Y = 8
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  bool mutate_x(int32_t _x) {
    return SetField<int32_t>(VT_X, _x, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  bool mutate_y(int32_t _y) {
    return SetField<int32_t>(VT_Y, _y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
  BulletT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BulletT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Bullet> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BulletT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BulletBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Bullet::VT_TYPE, type, 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(Bullet::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(Bullet::VT_Y, y, 0);
  }
  explicit BulletBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BulletBuilder &operator=(const BulletBuilder &);
  flatbuffers::Offset<Bullet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bullet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bullet> CreateBullet(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t x = 0,
    int32_t y = 0) {
  BulletBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Bullet> CreateBullet(flatbuffers::FlatBufferBuilder &_fbb, const BulletT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnitT : public flatbuffers::NativeTable {
  typedef Unit TableType;
  int32_t id;
  int32_t x;
  int32_t y;
  int32_t health;
  int32_t max_health;
  int32_t shield;
  int32_t max_shield;
  int32_t energy;
  int32_t maxCD;
  int32_t groundCD;
  int32_t airCD;
  bool visible;
  int32_t type;
  int32_t armor;
  int32_t shieldArmor;
  int32_t size;
  int32_t pixel_x;
  int32_t pixel_y;
  int32_t pixel_size_x;
  int32_t pixel_size_y;
  int32_t groundATK;
  int32_t airATK;
  int32_t groundDmgType;
  int32_t airDmgType;
  int32_t groundRange;
  int32_t airRange;
  std::vector<std::unique_ptr<OrderT>> orders;
  std::unique_ptr<UnitCommandT> command;
  double velocityX;
  double velocityY;
  int32_t playerId;
  int32_t resources;
  int32_t buildTechUpgradeType;
  int32_t remainingBuildTrainTime;
  int32_t remainingUgpradeResearchTime;
  int32_t spellCD;
  int32_t associatedUnit;
  int32_t associatedCount;
  UnitT()
      : id(0),
        x(0),
        y(0),
        health(0),
        max_health(0),
        shield(0),
        max_shield(0),
        energy(0),
        maxCD(0),
        groundCD(0),
        airCD(0),
        visible(false),
        type(0),
        armor(0),
        shieldArmor(0),
        size(0),
        pixel_x(0),
        pixel_y(0),
        pixel_size_x(0),
        pixel_size_y(0),
        groundATK(0),
        airATK(0),
        groundDmgType(0),
        airDmgType(0),
        groundRange(0),
        airRange(0),
        velocityX(0.0),
        velocityY(0.0),
        playerId(0),
        resources(0),
        buildTechUpgradeType(0),
        remainingBuildTrainTime(0),
        remainingUgpradeResearchTime(0),
        spellCD(0),
        associatedUnit(0),
        associatedCount(0) {
  }
};

struct Unit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnitT NativeTableType;
  enum {
    VT_ID = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_HEALTH = 10,
    VT_MAX_HEALTH = 12,
    VT_SHIELD = 14,
    VT_MAX_SHIELD = 16,
    VT_ENERGY = 18,
    VT_MAXCD = 20,
    VT_GROUNDCD = 22,
    VT_AIRCD = 24,
    VT_VISIBLE = 26,
    VT_TYPE = 28,
    VT_ARMOR = 30,
    VT_SHIELDARMOR = 32,
    VT_SIZE = 34,
    VT_PIXEL_X = 36,
    VT_PIXEL_Y = 38,
    VT_PIXEL_SIZE_X = 40,
    VT_PIXEL_SIZE_Y = 42,
    VT_GROUNDATK = 44,
    VT_AIRATK = 46,
    VT_GROUNDDMGTYPE = 48,
    VT_AIRDMGTYPE = 50,
    VT_GROUNDRANGE = 52,
    VT_AIRRANGE = 54,
    VT_ORDERS = 56,
    VT_COMMAND = 58,
    VT_VELOCITYX = 60,
    VT_VELOCITYY = 62,
    VT_PLAYERID = 64,
    VT_RESOURCES = 66,
    VT_BUILDTECHUPGRADETYPE = 68,
    VT_REMAININGBUILDTRAINTIME = 70,
    VT_REMAININGUGPRADERESEARCHTIME = 72,
    VT_SPELLCD = 74,
    VT_ASSOCIATEDUNIT = 76,
    VT_ASSOCIATEDCOUNT = 78
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool mutate_id(int32_t _id) {
    return SetField<int32_t>(VT_ID, _id, 0);
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  bool mutate_x(int32_t _x) {
    return SetField<int32_t>(VT_X, _x, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  bool mutate_y(int32_t _y) {
    return SetField<int32_t>(VT_Y, _y, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  bool mutate_health(int32_t _health) {
    return SetField<int32_t>(VT_HEALTH, _health, 0);
  }
  int32_t max_health() const {
    return GetField<int32_t>(VT_MAX_HEALTH, 0);
  }
  bool mutate_max_health(int32_t _max_health) {
    return SetField<int32_t>(VT_MAX_HEALTH, _max_health, 0);
  }
  int32_t shield() const {
    return GetField<int32_t>(VT_SHIELD, 0);
  }
  bool mutate_shield(int32_t _shield) {
    return SetField<int32_t>(VT_SHIELD, _shield, 0);
  }
  int32_t max_shield() const {
    return GetField<int32_t>(VT_MAX_SHIELD, 0);
  }
  bool mutate_max_shield(int32_t _max_shield) {
    return SetField<int32_t>(VT_MAX_SHIELD, _max_shield, 0);
  }
  int32_t energy() const {
    return GetField<int32_t>(VT_ENERGY, 0);
  }
  bool mutate_energy(int32_t _energy) {
    return SetField<int32_t>(VT_ENERGY, _energy, 0);
  }
  int32_t maxCD() const {
    return GetField<int32_t>(VT_MAXCD, 0);
  }
  bool mutate_maxCD(int32_t _maxCD) {
    return SetField<int32_t>(VT_MAXCD, _maxCD, 0);
  }
  int32_t groundCD() const {
    return GetField<int32_t>(VT_GROUNDCD, 0);
  }
  bool mutate_groundCD(int32_t _groundCD) {
    return SetField<int32_t>(VT_GROUNDCD, _groundCD, 0);
  }
  int32_t airCD() const {
    return GetField<int32_t>(VT_AIRCD, 0);
  }
  bool mutate_airCD(int32_t _airCD) {
    return SetField<int32_t>(VT_AIRCD, _airCD, 0);
  }
  bool visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool mutate_visible(bool _visible) {
    return SetField<uint8_t>(VT_VISIBLE, static_cast<uint8_t>(_visible), 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  int32_t armor() const {
    return GetField<int32_t>(VT_ARMOR, 0);
  }
  bool mutate_armor(int32_t _armor) {
    return SetField<int32_t>(VT_ARMOR, _armor, 0);
  }
  int32_t shieldArmor() const {
    return GetField<int32_t>(VT_SHIELDARMOR, 0);
  }
  bool mutate_shieldArmor(int32_t _shieldArmor) {
    return SetField<int32_t>(VT_SHIELDARMOR, _shieldArmor, 0);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  bool mutate_size(int32_t _size) {
    return SetField<int32_t>(VT_SIZE, _size, 0);
  }
  int32_t pixel_x() const {
    return GetField<int32_t>(VT_PIXEL_X, 0);
  }
  bool mutate_pixel_x(int32_t _pixel_x) {
    return SetField<int32_t>(VT_PIXEL_X, _pixel_x, 0);
  }
  int32_t pixel_y() const {
    return GetField<int32_t>(VT_PIXEL_Y, 0);
  }
  bool mutate_pixel_y(int32_t _pixel_y) {
    return SetField<int32_t>(VT_PIXEL_Y, _pixel_y, 0);
  }
  int32_t pixel_size_x() const {
    return GetField<int32_t>(VT_PIXEL_SIZE_X, 0);
  }
  bool mutate_pixel_size_x(int32_t _pixel_size_x) {
    return SetField<int32_t>(VT_PIXEL_SIZE_X, _pixel_size_x, 0);
  }
  int32_t pixel_size_y() const {
    return GetField<int32_t>(VT_PIXEL_SIZE_Y, 0);
  }
  bool mutate_pixel_size_y(int32_t _pixel_size_y) {
    return SetField<int32_t>(VT_PIXEL_SIZE_Y, _pixel_size_y, 0);
  }
  int32_t groundATK() const {
    return GetField<int32_t>(VT_GROUNDATK, 0);
  }
  bool mutate_groundATK(int32_t _groundATK) {
    return SetField<int32_t>(VT_GROUNDATK, _groundATK, 0);
  }
  int32_t airATK() const {
    return GetField<int32_t>(VT_AIRATK, 0);
  }
  bool mutate_airATK(int32_t _airATK) {
    return SetField<int32_t>(VT_AIRATK, _airATK, 0);
  }
  int32_t groundDmgType() const {
    return GetField<int32_t>(VT_GROUNDDMGTYPE, 0);
  }
  bool mutate_groundDmgType(int32_t _groundDmgType) {
    return SetField<int32_t>(VT_GROUNDDMGTYPE, _groundDmgType, 0);
  }
  int32_t airDmgType() const {
    return GetField<int32_t>(VT_AIRDMGTYPE, 0);
  }
  bool mutate_airDmgType(int32_t _airDmgType) {
    return SetField<int32_t>(VT_AIRDMGTYPE, _airDmgType, 0);
  }
  int32_t groundRange() const {
    return GetField<int32_t>(VT_GROUNDRANGE, 0);
  }
  bool mutate_groundRange(int32_t _groundRange) {
    return SetField<int32_t>(VT_GROUNDRANGE, _groundRange, 0);
  }
  int32_t airRange() const {
    return GetField<int32_t>(VT_AIRRANGE, 0);
  }
  bool mutate_airRange(int32_t _airRange) {
    return SetField<int32_t>(VT_AIRRANGE, _airRange, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Order>> *orders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Order>> *>(VT_ORDERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Order>> *mutable_orders() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Order>> *>(VT_ORDERS);
  }
  const UnitCommand *command() const {
    return GetPointer<const UnitCommand *>(VT_COMMAND);
  }
  UnitCommand *mutable_command() {
    return GetPointer<UnitCommand *>(VT_COMMAND);
  }
  double velocityX() const {
    return GetField<double>(VT_VELOCITYX, 0.0);
  }
  bool mutate_velocityX(double _velocityX) {
    return SetField<double>(VT_VELOCITYX, _velocityX, 0.0);
  }
  double velocityY() const {
    return GetField<double>(VT_VELOCITYY, 0.0);
  }
  bool mutate_velocityY(double _velocityY) {
    return SetField<double>(VT_VELOCITYY, _velocityY, 0.0);
  }
  int32_t playerId() const {
    return GetField<int32_t>(VT_PLAYERID, 0);
  }
  bool mutate_playerId(int32_t _playerId) {
    return SetField<int32_t>(VT_PLAYERID, _playerId, 0);
  }
  int32_t resources() const {
    return GetField<int32_t>(VT_RESOURCES, 0);
  }
  bool mutate_resources(int32_t _resources) {
    return SetField<int32_t>(VT_RESOURCES, _resources, 0);
  }
  int32_t buildTechUpgradeType() const {
    return GetField<int32_t>(VT_BUILDTECHUPGRADETYPE, 0);
  }
  bool mutate_buildTechUpgradeType(int32_t _buildTechUpgradeType) {
    return SetField<int32_t>(VT_BUILDTECHUPGRADETYPE, _buildTechUpgradeType, 0);
  }
  int32_t remainingBuildTrainTime() const {
    return GetField<int32_t>(VT_REMAININGBUILDTRAINTIME, 0);
  }
  bool mutate_remainingBuildTrainTime(int32_t _remainingBuildTrainTime) {
    return SetField<int32_t>(VT_REMAININGBUILDTRAINTIME, _remainingBuildTrainTime, 0);
  }
  int32_t remainingUgpradeResearchTime() const {
    return GetField<int32_t>(VT_REMAININGUGPRADERESEARCHTIME, 0);
  }
  bool mutate_remainingUgpradeResearchTime(int32_t _remainingUgpradeResearchTime) {
    return SetField<int32_t>(VT_REMAININGUGPRADERESEARCHTIME, _remainingUgpradeResearchTime, 0);
  }
  int32_t spellCD() const {
    return GetField<int32_t>(VT_SPELLCD, 0);
  }
  bool mutate_spellCD(int32_t _spellCD) {
    return SetField<int32_t>(VT_SPELLCD, _spellCD, 0);
  }
  int32_t associatedUnit() const {
    return GetField<int32_t>(VT_ASSOCIATEDUNIT, 0);
  }
  bool mutate_associatedUnit(int32_t _associatedUnit) {
    return SetField<int32_t>(VT_ASSOCIATEDUNIT, _associatedUnit, 0);
  }
  int32_t associatedCount() const {
    return GetField<int32_t>(VT_ASSOCIATEDCOUNT, 0);
  }
  bool mutate_associatedCount(int32_t _associatedCount) {
    return SetField<int32_t>(VT_ASSOCIATEDCOUNT, _associatedCount, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_HEALTH) &&
           VerifyField<int32_t>(verifier, VT_MAX_HEALTH) &&
           VerifyField<int32_t>(verifier, VT_SHIELD) &&
           VerifyField<int32_t>(verifier, VT_MAX_SHIELD) &&
           VerifyField<int32_t>(verifier, VT_ENERGY) &&
           VerifyField<int32_t>(verifier, VT_MAXCD) &&
           VerifyField<int32_t>(verifier, VT_GROUNDCD) &&
           VerifyField<int32_t>(verifier, VT_AIRCD) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ARMOR) &&
           VerifyField<int32_t>(verifier, VT_SHIELDARMOR) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_PIXEL_X) &&
           VerifyField<int32_t>(verifier, VT_PIXEL_Y) &&
           VerifyField<int32_t>(verifier, VT_PIXEL_SIZE_X) &&
           VerifyField<int32_t>(verifier, VT_PIXEL_SIZE_Y) &&
           VerifyField<int32_t>(verifier, VT_GROUNDATK) &&
           VerifyField<int32_t>(verifier, VT_AIRATK) &&
           VerifyField<int32_t>(verifier, VT_GROUNDDMGTYPE) &&
           VerifyField<int32_t>(verifier, VT_AIRDMGTYPE) &&
           VerifyField<int32_t>(verifier, VT_GROUNDRANGE) &&
           VerifyField<int32_t>(verifier, VT_AIRRANGE) &&
           VerifyOffset(verifier, VT_ORDERS) &&
           verifier.Verify(orders()) &&
           verifier.VerifyVectorOfTables(orders()) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyTable(command()) &&
           VerifyField<double>(verifier, VT_VELOCITYX) &&
           VerifyField<double>(verifier, VT_VELOCITYY) &&
           VerifyField<int32_t>(verifier, VT_PLAYERID) &&
           VerifyField<int32_t>(verifier, VT_RESOURCES) &&
           VerifyField<int32_t>(verifier, VT_BUILDTECHUPGRADETYPE) &&
           VerifyField<int32_t>(verifier, VT_REMAININGBUILDTRAINTIME) &&
           VerifyField<int32_t>(verifier, VT_REMAININGUGPRADERESEARCHTIME) &&
           VerifyField<int32_t>(verifier, VT_SPELLCD) &&
           VerifyField<int32_t>(verifier, VT_ASSOCIATEDUNIT) &&
           VerifyField<int32_t>(verifier, VT_ASSOCIATEDCOUNT) &&
           verifier.EndTable();
  }
  UnitT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnitT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unit> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Unit::VT_ID, id, 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(Unit::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(Unit::VT_Y, y, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(Unit::VT_HEALTH, health, 0);
  }
  void add_max_health(int32_t max_health) {
    fbb_.AddElement<int32_t>(Unit::VT_MAX_HEALTH, max_health, 0);
  }
  void add_shield(int32_t shield) {
    fbb_.AddElement<int32_t>(Unit::VT_SHIELD, shield, 0);
  }
  void add_max_shield(int32_t max_shield) {
    fbb_.AddElement<int32_t>(Unit::VT_MAX_SHIELD, max_shield, 0);
  }
  void add_energy(int32_t energy) {
    fbb_.AddElement<int32_t>(Unit::VT_ENERGY, energy, 0);
  }
  void add_maxCD(int32_t maxCD) {
    fbb_.AddElement<int32_t>(Unit::VT_MAXCD, maxCD, 0);
  }
  void add_groundCD(int32_t groundCD) {
    fbb_.AddElement<int32_t>(Unit::VT_GROUNDCD, groundCD, 0);
  }
  void add_airCD(int32_t airCD) {
    fbb_.AddElement<int32_t>(Unit::VT_AIRCD, airCD, 0);
  }
  void add_visible(bool visible) {
    fbb_.AddElement<uint8_t>(Unit::VT_VISIBLE, static_cast<uint8_t>(visible), 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Unit::VT_TYPE, type, 0);
  }
  void add_armor(int32_t armor) {
    fbb_.AddElement<int32_t>(Unit::VT_ARMOR, armor, 0);
  }
  void add_shieldArmor(int32_t shieldArmor) {
    fbb_.AddElement<int32_t>(Unit::VT_SHIELDARMOR, shieldArmor, 0);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(Unit::VT_SIZE, size, 0);
  }
  void add_pixel_x(int32_t pixel_x) {
    fbb_.AddElement<int32_t>(Unit::VT_PIXEL_X, pixel_x, 0);
  }
  void add_pixel_y(int32_t pixel_y) {
    fbb_.AddElement<int32_t>(Unit::VT_PIXEL_Y, pixel_y, 0);
  }
  void add_pixel_size_x(int32_t pixel_size_x) {
    fbb_.AddElement<int32_t>(Unit::VT_PIXEL_SIZE_X, pixel_size_x, 0);
  }
  void add_pixel_size_y(int32_t pixel_size_y) {
    fbb_.AddElement<int32_t>(Unit::VT_PIXEL_SIZE_Y, pixel_size_y, 0);
  }
  void add_groundATK(int32_t groundATK) {
    fbb_.AddElement<int32_t>(Unit::VT_GROUNDATK, groundATK, 0);
  }
  void add_airATK(int32_t airATK) {
    fbb_.AddElement<int32_t>(Unit::VT_AIRATK, airATK, 0);
  }
  void add_groundDmgType(int32_t groundDmgType) {
    fbb_.AddElement<int32_t>(Unit::VT_GROUNDDMGTYPE, groundDmgType, 0);
  }
  void add_airDmgType(int32_t airDmgType) {
    fbb_.AddElement<int32_t>(Unit::VT_AIRDMGTYPE, airDmgType, 0);
  }
  void add_groundRange(int32_t groundRange) {
    fbb_.AddElement<int32_t>(Unit::VT_GROUNDRANGE, groundRange, 0);
  }
  void add_airRange(int32_t airRange) {
    fbb_.AddElement<int32_t>(Unit::VT_AIRRANGE, airRange, 0);
  }
  void add_orders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Order>>> orders) {
    fbb_.AddOffset(Unit::VT_ORDERS, orders);
  }
  void add_command(flatbuffers::Offset<UnitCommand> command) {
    fbb_.AddOffset(Unit::VT_COMMAND, command);
  }
  void add_velocityX(double velocityX) {
    fbb_.AddElement<double>(Unit::VT_VELOCITYX, velocityX, 0.0);
  }
  void add_velocityY(double velocityY) {
    fbb_.AddElement<double>(Unit::VT_VELOCITYY, velocityY, 0.0);
  }
  void add_playerId(int32_t playerId) {
    fbb_.AddElement<int32_t>(Unit::VT_PLAYERID, playerId, 0);
  }
  void add_resources(int32_t resources) {
    fbb_.AddElement<int32_t>(Unit::VT_RESOURCES, resources, 0);
  }
  void add_buildTechUpgradeType(int32_t buildTechUpgradeType) {
    fbb_.AddElement<int32_t>(Unit::VT_BUILDTECHUPGRADETYPE, buildTechUpgradeType, 0);
  }
  void add_remainingBuildTrainTime(int32_t remainingBuildTrainTime) {
    fbb_.AddElement<int32_t>(Unit::VT_REMAININGBUILDTRAINTIME, remainingBuildTrainTime, 0);
  }
  void add_remainingUgpradeResearchTime(int32_t remainingUgpradeResearchTime) {
    fbb_.AddElement<int32_t>(Unit::VT_REMAININGUGPRADERESEARCHTIME, remainingUgpradeResearchTime, 0);
  }
  void add_spellCD(int32_t spellCD) {
    fbb_.AddElement<int32_t>(Unit::VT_SPELLCD, spellCD, 0);
  }
  void add_associatedUnit(int32_t associatedUnit) {
    fbb_.AddElement<int32_t>(Unit::VT_ASSOCIATEDUNIT, associatedUnit, 0);
  }
  void add_associatedCount(int32_t associatedCount) {
    fbb_.AddElement<int32_t>(Unit::VT_ASSOCIATEDCOUNT, associatedCount, 0);
  }
  explicit UnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitBuilder &operator=(const UnitBuilder &);
  flatbuffers::Offset<Unit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unit> CreateUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t x = 0,
    int32_t y = 0,
    int32_t health = 0,
    int32_t max_health = 0,
    int32_t shield = 0,
    int32_t max_shield = 0,
    int32_t energy = 0,
    int32_t maxCD = 0,
    int32_t groundCD = 0,
    int32_t airCD = 0,
    bool visible = false,
    int32_t type = 0,
    int32_t armor = 0,
    int32_t shieldArmor = 0,
    int32_t size = 0,
    int32_t pixel_x = 0,
    int32_t pixel_y = 0,
    int32_t pixel_size_x = 0,
    int32_t pixel_size_y = 0,
    int32_t groundATK = 0,
    int32_t airATK = 0,
    int32_t groundDmgType = 0,
    int32_t airDmgType = 0,
    int32_t groundRange = 0,
    int32_t airRange = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Order>>> orders = 0,
    flatbuffers::Offset<UnitCommand> command = 0,
    double velocityX = 0.0,
    double velocityY = 0.0,
    int32_t playerId = 0,
    int32_t resources = 0,
    int32_t buildTechUpgradeType = 0,
    int32_t remainingBuildTrainTime = 0,
    int32_t remainingUgpradeResearchTime = 0,
    int32_t spellCD = 0,
    int32_t associatedUnit = 0,
    int32_t associatedCount = 0) {
  UnitBuilder builder_(_fbb);
  builder_.add_velocityY(velocityY);
  builder_.add_velocityX(velocityX);
  builder_.add_associatedCount(associatedCount);
  builder_.add_associatedUnit(associatedUnit);
  builder_.add_spellCD(spellCD);
  builder_.add_remainingUgpradeResearchTime(remainingUgpradeResearchTime);
  builder_.add_remainingBuildTrainTime(remainingBuildTrainTime);
  builder_.add_buildTechUpgradeType(buildTechUpgradeType);
  builder_.add_resources(resources);
  builder_.add_playerId(playerId);
  builder_.add_command(command);
  builder_.add_orders(orders);
  builder_.add_airRange(airRange);
  builder_.add_groundRange(groundRange);
  builder_.add_airDmgType(airDmgType);
  builder_.add_groundDmgType(groundDmgType);
  builder_.add_airATK(airATK);
  builder_.add_groundATK(groundATK);
  builder_.add_pixel_size_y(pixel_size_y);
  builder_.add_pixel_size_x(pixel_size_x);
  builder_.add_pixel_y(pixel_y);
  builder_.add_pixel_x(pixel_x);
  builder_.add_size(size);
  builder_.add_shieldArmor(shieldArmor);
  builder_.add_armor(armor);
  builder_.add_type(type);
  builder_.add_airCD(airCD);
  builder_.add_groundCD(groundCD);
  builder_.add_maxCD(maxCD);
  builder_.add_energy(energy);
  builder_.add_max_shield(max_shield);
  builder_.add_shield(shield);
  builder_.add_max_health(max_health);
  builder_.add_health(health);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_id(id);
  builder_.add_visible(visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unit> CreateUnitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t x = 0,
    int32_t y = 0,
    int32_t health = 0,
    int32_t max_health = 0,
    int32_t shield = 0,
    int32_t max_shield = 0,
    int32_t energy = 0,
    int32_t maxCD = 0,
    int32_t groundCD = 0,
    int32_t airCD = 0,
    bool visible = false,
    int32_t type = 0,
    int32_t armor = 0,
    int32_t shieldArmor = 0,
    int32_t size = 0,
    int32_t pixel_x = 0,
    int32_t pixel_y = 0,
    int32_t pixel_size_x = 0,
    int32_t pixel_size_y = 0,
    int32_t groundATK = 0,
    int32_t airATK = 0,
    int32_t groundDmgType = 0,
    int32_t airDmgType = 0,
    int32_t groundRange = 0,
    int32_t airRange = 0,
    const std::vector<flatbuffers::Offset<Order>> *orders = nullptr,
    flatbuffers::Offset<UnitCommand> command = 0,
    double velocityX = 0.0,
    double velocityY = 0.0,
    int32_t playerId = 0,
    int32_t resources = 0,
    int32_t buildTechUpgradeType = 0,
    int32_t remainingBuildTrainTime = 0,
    int32_t remainingUgpradeResearchTime = 0,
    int32_t spellCD = 0,
    int32_t associatedUnit = 0,
    int32_t associatedCount = 0) {
  return torchcraft::fbs::CreateUnit(
      _fbb,
      id,
      x,
      y,
      health,
      max_health,
      shield,
      max_shield,
      energy,
      maxCD,
      groundCD,
      airCD,
      visible,
      type,
      armor,
      shieldArmor,
      size,
      pixel_x,
      pixel_y,
      pixel_size_x,
      pixel_size_y,
      groundATK,
      airATK,
      groundDmgType,
      airDmgType,
      groundRange,
      airRange,
      orders ? _fbb.CreateVector<flatbuffers::Offset<Order>>(*orders) : 0,
      command,
      velocityX,
      velocityY,
      playerId,
      resources,
      buildTechUpgradeType,
      remainingBuildTrainTime,
      remainingUgpradeResearchTime,
      spellCD,
      associatedUnit,
      associatedCount);
}

flatbuffers::Offset<Unit> CreateUnit(flatbuffers::FlatBufferBuilder &_fbb, const UnitT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameT : public flatbuffers::NativeTable {
  typedef Frame TableType;
  std::vector<std::unique_ptr<BulletT>> bullets;
  std::vector<uint8_t> creep_map;
  uint32_t width;
  uint32_t height;
  int32_t reward;
  bool is_terminal;
  FrameT()
      : width(0),
        height(0),
        reward(0),
        is_terminal(false) {
  }
};

struct Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameT NativeTableType;
  enum {
    VT_BULLETS = 4,
    VT_CREEP_MAP = 6,
    VT_WIDTH = 8,
    VT_HEIGHT = 10,
    VT_REWARD = 12,
    VT_IS_TERMINAL = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<Bullet>> *bullets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Bullet>> *>(VT_BULLETS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Bullet>> *mutable_bullets() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Bullet>> *>(VT_BULLETS);
  }
  const flatbuffers::Vector<uint8_t> *creep_map() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CREEP_MAP);
  }
  flatbuffers::Vector<uint8_t> *mutable_creep_map() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CREEP_MAP);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  bool mutate_width(uint32_t _width) {
    return SetField<uint32_t>(VT_WIDTH, _width, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool mutate_height(uint32_t _height) {
    return SetField<uint32_t>(VT_HEIGHT, _height, 0);
  }
  int32_t reward() const {
    return GetField<int32_t>(VT_REWARD, 0);
  }
  bool mutate_reward(int32_t _reward) {
    return SetField<int32_t>(VT_REWARD, _reward, 0);
  }
  bool is_terminal() const {
    return GetField<uint8_t>(VT_IS_TERMINAL, 0) != 0;
  }
  bool mutate_is_terminal(bool _is_terminal) {
    return SetField<uint8_t>(VT_IS_TERMINAL, static_cast<uint8_t>(_is_terminal), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BULLETS) &&
           verifier.Verify(bullets()) &&
           verifier.VerifyVectorOfTables(bullets()) &&
           VerifyOffset(verifier, VT_CREEP_MAP) &&
           verifier.Verify(creep_map()) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_REWARD) &&
           VerifyField<uint8_t>(verifier, VT_IS_TERMINAL) &&
           verifier.EndTable();
  }
  FrameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Frame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bullets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bullet>>> bullets) {
    fbb_.AddOffset(Frame::VT_BULLETS, bullets);
  }
  void add_creep_map(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> creep_map) {
    fbb_.AddOffset(Frame::VT_CREEP_MAP, creep_map);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(Frame::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(Frame::VT_HEIGHT, height, 0);
  }
  void add_reward(int32_t reward) {
    fbb_.AddElement<int32_t>(Frame::VT_REWARD, reward, 0);
  }
  void add_is_terminal(bool is_terminal) {
    fbb_.AddElement<uint8_t>(Frame::VT_IS_TERMINAL, static_cast<uint8_t>(is_terminal), 0);
  }
  explicit FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameBuilder &operator=(const FrameBuilder &);
  flatbuffers::Offset<Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Frame>(end);
    return o;
  }
};

inline flatbuffers::Offset<Frame> CreateFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bullet>>> bullets = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> creep_map = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    int32_t reward = 0,
    bool is_terminal = false) {
  FrameBuilder builder_(_fbb);
  builder_.add_reward(reward);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_creep_map(creep_map);
  builder_.add_bullets(bullets);
  builder_.add_is_terminal(is_terminal);
  return builder_.Finish();
}

inline flatbuffers::Offset<Frame> CreateFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Bullet>> *bullets = nullptr,
    const std::vector<uint8_t> *creep_map = nullptr,
    uint32_t width = 0,
    uint32_t height = 0,
    int32_t reward = 0,
    bool is_terminal = false) {
  return torchcraft::fbs::CreateFrame(
      _fbb,
      bullets ? _fbb.CreateVector<flatbuffers::Offset<Bullet>>(*bullets) : 0,
      creep_map ? _fbb.CreateVector<uint8_t>(*creep_map) : 0,
      width,
      height,
      reward,
      is_terminal);
}

flatbuffers::Offset<Frame> CreateFrame(flatbuffers::FlatBufferBuilder &_fbb, const FrameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameContainerT : public flatbuffers::NativeTable {
  typedef FrameContainer TableType;
  std::vector<std::unique_ptr<FrameT>> frames;
  FrameContainerT() {
  }
};

struct FrameContainer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameContainerT NativeTableType;
  enum {
    VT_FRAMES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Frame>> *frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Frame>> *>(VT_FRAMES);
  }
  flatbuffers::Vector<flatbuffers::Offset<Frame>> *mutable_frames() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Frame>> *>(VT_FRAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FRAMES) &&
           verifier.Verify(frames()) &&
           verifier.VerifyVectorOfTables(frames()) &&
           verifier.EndTable();
  }
  FrameContainerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameContainerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FrameContainer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameContainerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> frames) {
    fbb_.AddOffset(FrameContainer::VT_FRAMES, frames);
  }
  explicit FrameContainerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameContainerBuilder &operator=(const FrameContainerBuilder &);
  flatbuffers::Offset<FrameContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FrameContainer>(end);
    return o;
  }
};

inline flatbuffers::Offset<FrameContainer> CreateFrameContainer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> frames = 0) {
  FrameContainerBuilder builder_(_fbb);
  builder_.add_frames(frames);
  return builder_.Finish();
}

inline flatbuffers::Offset<FrameContainer> CreateFrameContainerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Frame>> *frames = nullptr) {
  return torchcraft::fbs::CreateFrameContainer(
      _fbb,
      frames ? _fbb.CreateVector<flatbuffers::Offset<Frame>>(*frames) : 0);
}

flatbuffers::Offset<FrameContainer> CreateFrameContainer(flatbuffers::FlatBufferBuilder &_fbb, const FrameContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MapT *Map::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Map::UnPackTo(MapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = height(); _o->height = _e; };
  { auto _e = width(); _o->width = _e; };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Map> Map::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Map> CreateMap(flatbuffers::FlatBufferBuilder &_fbb, const MapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _height = _o->height;
  auto _width = _o->width;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return torchcraft::fbs::CreateMap(
      _fbb,
      _height,
      _width,
      _data);
}

inline ActionT *Action::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ActionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Action::UnPackTo(ActionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = action(); if (_e) { _o->action.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->action[_i] = _e->Get(_i); } } };
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = aid(); _o->aid = _e; };
}

inline flatbuffers::Offset<Action> Action::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAction(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Action> CreateAction(flatbuffers::FlatBufferBuilder &_fbb, const ActionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _action = _o->action.size() ? _fbb.CreateVector(_o->action) : 0;
  auto _uid = _o->uid;
  auto _aid = _o->aid;
  return torchcraft::fbs::CreateAction(
      _fbb,
      _action,
      _uid,
      _aid);
}

inline ResourcesT *Resources::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResourcesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Resources::UnPackTo(ResourcesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ore(); _o->ore = _e; };
  { auto _e = gas(); _o->gas = _e; };
  { auto _e = used_psi(); _o->used_psi = _e; };
  { auto _e = total_psi(); _o->total_psi = _e; };
  { auto _e = upgrades(); _o->upgrades = _e; };
  { auto _e = upgrades_level(); _o->upgrades_level = _e; };
  { auto _e = techs(); _o->techs = _e; };
}

inline flatbuffers::Offset<Resources> Resources::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResources(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Resources> CreateResources(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResourcesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ore = _o->ore;
  auto _gas = _o->gas;
  auto _used_psi = _o->used_psi;
  auto _total_psi = _o->total_psi;
  auto _upgrades = _o->upgrades;
  auto _upgrades_level = _o->upgrades_level;
  auto _techs = _o->techs;
  return torchcraft::fbs::CreateResources(
      _fbb,
      _ore,
      _gas,
      _used_psi,
      _total_psi,
      _upgrades,
      _upgrades_level,
      _techs);
}

inline OrderT *Order::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OrderT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Order::UnPackTo(OrderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = first_frame(); _o->first_frame = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = targetId(); _o->targetId = _e; };
  { auto _e = targetX(); _o->targetX = _e; };
  { auto _e = targetY(); _o->targetY = _e; };
}

inline flatbuffers::Offset<Order> Order::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OrderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOrder(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Order> CreateOrder(flatbuffers::FlatBufferBuilder &_fbb, const OrderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OrderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _first_frame = _o->first_frame;
  auto _type = _o->type;
  auto _targetId = _o->targetId;
  auto _targetX = _o->targetX;
  auto _targetY = _o->targetY;
  return torchcraft::fbs::CreateOrder(
      _fbb,
      _first_frame,
      _type,
      _targetId,
      _targetX,
      _targetY);
}

inline UnitCommandT *UnitCommand::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnitCommandT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnitCommand::UnPackTo(UnitCommandT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = farme(); _o->farme = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = targetId(); _o->targetId = _e; };
  { auto _e = targetX(); _o->targetX = _e; };
  { auto _e = targetY(); _o->targetY = _e; };
  { auto _e = extra(); _o->extra = _e; };
}

inline flatbuffers::Offset<UnitCommand> UnitCommand::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnitCommand(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnitCommand> CreateUnitCommand(flatbuffers::FlatBufferBuilder &_fbb, const UnitCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnitCommandT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _farme = _o->farme;
  auto _type = _o->type;
  auto _targetId = _o->targetId;
  auto _targetX = _o->targetX;
  auto _targetY = _o->targetY;
  auto _extra = _o->extra;
  return torchcraft::fbs::CreateUnitCommand(
      _fbb,
      _farme,
      _type,
      _targetId,
      _targetX,
      _targetY,
      _extra);
}

inline BulletT *Bullet::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BulletT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Bullet::UnPackTo(BulletT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = x(); _o->x = _e; };
  { auto _e = y(); _o->y = _e; };
}

inline flatbuffers::Offset<Bullet> Bullet::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BulletT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBullet(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Bullet> CreateBullet(flatbuffers::FlatBufferBuilder &_fbb, const BulletT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BulletT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _x = _o->x;
  auto _y = _o->y;
  return torchcraft::fbs::CreateBullet(
      _fbb,
      _type,
      _x,
      _y);
}

inline UnitT *Unit::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnitT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Unit::UnPackTo(UnitT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = x(); _o->x = _e; };
  { auto _e = y(); _o->y = _e; };
  { auto _e = health(); _o->health = _e; };
  { auto _e = max_health(); _o->max_health = _e; };
  { auto _e = shield(); _o->shield = _e; };
  { auto _e = max_shield(); _o->max_shield = _e; };
  { auto _e = energy(); _o->energy = _e; };
  { auto _e = maxCD(); _o->maxCD = _e; };
  { auto _e = groundCD(); _o->groundCD = _e; };
  { auto _e = airCD(); _o->airCD = _e; };
  { auto _e = visible(); _o->visible = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = armor(); _o->armor = _e; };
  { auto _e = shieldArmor(); _o->shieldArmor = _e; };
  { auto _e = size(); _o->size = _e; };
  { auto _e = pixel_x(); _o->pixel_x = _e; };
  { auto _e = pixel_y(); _o->pixel_y = _e; };
  { auto _e = pixel_size_x(); _o->pixel_size_x = _e; };
  { auto _e = pixel_size_y(); _o->pixel_size_y = _e; };
  { auto _e = groundATK(); _o->groundATK = _e; };
  { auto _e = airATK(); _o->airATK = _e; };
  { auto _e = groundDmgType(); _o->groundDmgType = _e; };
  { auto _e = airDmgType(); _o->airDmgType = _e; };
  { auto _e = groundRange(); _o->groundRange = _e; };
  { auto _e = airRange(); _o->airRange = _e; };
  { auto _e = orders(); if (_e) { _o->orders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->orders[_i] = std::unique_ptr<OrderT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = command(); if (_e) _o->command = std::unique_ptr<UnitCommandT>(_e->UnPack(_resolver)); };
  { auto _e = velocityX(); _o->velocityX = _e; };
  { auto _e = velocityY(); _o->velocityY = _e; };
  { auto _e = playerId(); _o->playerId = _e; };
  { auto _e = resources(); _o->resources = _e; };
  { auto _e = buildTechUpgradeType(); _o->buildTechUpgradeType = _e; };
  { auto _e = remainingBuildTrainTime(); _o->remainingBuildTrainTime = _e; };
  { auto _e = remainingUgpradeResearchTime(); _o->remainingUgpradeResearchTime = _e; };
  { auto _e = spellCD(); _o->spellCD = _e; };
  { auto _e = associatedUnit(); _o->associatedUnit = _e; };
  { auto _e = associatedCount(); _o->associatedCount = _e; };
}

inline flatbuffers::Offset<Unit> Unit::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnit(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unit> CreateUnit(flatbuffers::FlatBufferBuilder &_fbb, const UnitT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnitT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _health = _o->health;
  auto _max_health = _o->max_health;
  auto _shield = _o->shield;
  auto _max_shield = _o->max_shield;
  auto _energy = _o->energy;
  auto _maxCD = _o->maxCD;
  auto _groundCD = _o->groundCD;
  auto _airCD = _o->airCD;
  auto _visible = _o->visible;
  auto _type = _o->type;
  auto _armor = _o->armor;
  auto _shieldArmor = _o->shieldArmor;
  auto _size = _o->size;
  auto _pixel_x = _o->pixel_x;
  auto _pixel_y = _o->pixel_y;
  auto _pixel_size_x = _o->pixel_size_x;
  auto _pixel_size_y = _o->pixel_size_y;
  auto _groundATK = _o->groundATK;
  auto _airATK = _o->airATK;
  auto _groundDmgType = _o->groundDmgType;
  auto _airDmgType = _o->airDmgType;
  auto _groundRange = _o->groundRange;
  auto _airRange = _o->airRange;
  auto _orders = _o->orders.size() ? _fbb.CreateVector<flatbuffers::Offset<Order>> (_o->orders.size(), [](size_t i, _VectorArgs *__va) { return CreateOrder(*__va->__fbb, __va->__o->orders[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _command = _o->command ? CreateUnitCommand(_fbb, _o->command.get(), _rehasher) : 0;
  auto _velocityX = _o->velocityX;
  auto _velocityY = _o->velocityY;
  auto _playerId = _o->playerId;
  auto _resources = _o->resources;
  auto _buildTechUpgradeType = _o->buildTechUpgradeType;
  auto _remainingBuildTrainTime = _o->remainingBuildTrainTime;
  auto _remainingUgpradeResearchTime = _o->remainingUgpradeResearchTime;
  auto _spellCD = _o->spellCD;
  auto _associatedUnit = _o->associatedUnit;
  auto _associatedCount = _o->associatedCount;
  return torchcraft::fbs::CreateUnit(
      _fbb,
      _id,
      _x,
      _y,
      _health,
      _max_health,
      _shield,
      _max_shield,
      _energy,
      _maxCD,
      _groundCD,
      _airCD,
      _visible,
      _type,
      _armor,
      _shieldArmor,
      _size,
      _pixel_x,
      _pixel_y,
      _pixel_size_x,
      _pixel_size_y,
      _groundATK,
      _airATK,
      _groundDmgType,
      _airDmgType,
      _groundRange,
      _airRange,
      _orders,
      _command,
      _velocityX,
      _velocityY,
      _playerId,
      _resources,
      _buildTechUpgradeType,
      _remainingBuildTrainTime,
      _remainingUgpradeResearchTime,
      _spellCD,
      _associatedUnit,
      _associatedCount);
}

inline FrameT *Frame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FrameT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Frame::UnPackTo(FrameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = bullets(); if (_e) { _o->bullets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bullets[_i] = std::unique_ptr<BulletT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = creep_map(); if (_e) { _o->creep_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->creep_map[_i] = _e->Get(_i); } } };
  { auto _e = width(); _o->width = _e; };
  { auto _e = height(); _o->height = _e; };
  { auto _e = reward(); _o->reward = _e; };
  { auto _e = is_terminal(); _o->is_terminal = _e; };
}

inline flatbuffers::Offset<Frame> Frame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Frame> CreateFrame(flatbuffers::FlatBufferBuilder &_fbb, const FrameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FrameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _bullets = _o->bullets.size() ? _fbb.CreateVector<flatbuffers::Offset<Bullet>> (_o->bullets.size(), [](size_t i, _VectorArgs *__va) { return CreateBullet(*__va->__fbb, __va->__o->bullets[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _creep_map = _o->creep_map.size() ? _fbb.CreateVector(_o->creep_map) : 0;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _reward = _o->reward;
  auto _is_terminal = _o->is_terminal;
  return torchcraft::fbs::CreateFrame(
      _fbb,
      _bullets,
      _creep_map,
      _width,
      _height,
      _reward,
      _is_terminal);
}

inline FrameContainerT *FrameContainer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FrameContainerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FrameContainer::UnPackTo(FrameContainerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frames(); if (_e) { _o->frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->frames[_i] = std::unique_ptr<FrameT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<FrameContainer> FrameContainer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrameContainer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FrameContainer> CreateFrameContainer(flatbuffers::FlatBufferBuilder &_fbb, const FrameContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FrameContainerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frames = _o->frames.size() ? _fbb.CreateVector<flatbuffers::Offset<Frame>> (_o->frames.size(), [](size_t i, _VectorArgs *__va) { return CreateFrame(*__va->__fbb, __va->__o->frames[i].get(), __va->__rehasher); }, &_va ) : 0;
  return torchcraft::fbs::CreateFrameContainer(
      _fbb,
      _frames);
}

inline const torchcraft::fbs::FrameContainer *GetFrameContainer(const void *buf) {
  return flatbuffers::GetRoot<torchcraft::fbs::FrameContainer>(buf);
}

inline FrameContainer *GetMutableFrameContainer(void *buf) {
  return flatbuffers::GetMutableRoot<FrameContainer>(buf);
}

inline bool VerifyFrameContainerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<torchcraft::fbs::FrameContainer>(nullptr);
}

inline void FinishFrameContainerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<torchcraft::fbs::FrameContainer> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<FrameContainerT> UnPackFrameContainer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<FrameContainerT>(GetFrameContainer(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace torchcraft

#endif  // FLATBUFFERS_GENERATED_FRAME_TORCHCRAFT_FBS_H_
