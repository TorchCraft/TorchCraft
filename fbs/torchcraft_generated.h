// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TORCHCRAFT_TORCHCRAFT_FBS_H_
#define FLATBUFFERS_GENERATED_TORCHCRAFT_TORCHCRAFT_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace torchcraft {
namespace fbs {

struct Vec2;

struct Command;
struct CommandT;

struct Player;
struct PlayerT;

struct HandshakeClient;
struct HandshakeClientT;

struct HandshakeServer;
struct HandshakeServerT;

struct Commands;
struct CommandsT;

struct FrameState;
struct FrameStateT;

struct PlayerLeft;
struct PlayerLeftT;

struct EndGame;
struct EndGameT;

struct Error;
struct ErrorT;

struct Message;
struct MessageT;

struct Map;
struct MapT;

struct Action;
struct ActionT;

struct Resources;
struct ResourcesT;

struct Order;
struct OrderT;

struct UnitCommand;
struct UnitCommandT;

struct Bullet;
struct BulletT;

struct Unit;
struct UnitT;

struct UnitsByPlayerId;
struct UnitsByPlayerIdT;

struct ActionsByPlayerId;
struct ActionsByPlayerIdT;

struct ResourcesByPlayerId;
struct ResourcesByPlayerIdT;

struct Frame;
struct FrameT;

struct UnitDiff;
struct UnitDiffT;

struct UnitDiffContainer;
struct UnitDiffContainerT;

struct FrameDiffCreep;
struct FrameDiffCreepT;

struct FrameDiff;
struct FrameDiffT;

struct UnitCount;
struct UnitCountT;

struct Replayer;
struct ReplayerT;

enum class FrameOrFrameDiff : uint8_t {
  NONE = 0,
  Frame = 1,
  FrameDiff = 2,
  MIN = NONE,
  MAX = FrameDiff
};

inline FrameOrFrameDiff (&EnumValuesFrameOrFrameDiff())[3] {
  static FrameOrFrameDiff values[] = {
    FrameOrFrameDiff::NONE,
    FrameOrFrameDiff::Frame,
    FrameOrFrameDiff::FrameDiff
  };
  return values;
}

inline const char **EnumNamesFrameOrFrameDiff() {
  static const char *names[] = {
    "NONE",
    "Frame",
    "FrameDiff",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrameOrFrameDiff(FrameOrFrameDiff e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFrameOrFrameDiff()[index];
}

template<typename T> struct FrameOrFrameDiffTraits {
  static const FrameOrFrameDiff enum_value = FrameOrFrameDiff::NONE;
};

template<> struct FrameOrFrameDiffTraits<Frame> {
  static const FrameOrFrameDiff enum_value = FrameOrFrameDiff::Frame;
};

template<> struct FrameOrFrameDiffTraits<FrameDiff> {
  static const FrameOrFrameDiff enum_value = FrameOrFrameDiff::FrameDiff;
};

struct FrameOrFrameDiffUnion {
  FrameOrFrameDiff type;
  void *value;

  FrameOrFrameDiffUnion() : type(FrameOrFrameDiff::NONE), value(nullptr) {}
  FrameOrFrameDiffUnion(FrameOrFrameDiffUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(FrameOrFrameDiff::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  FrameOrFrameDiffUnion(const FrameOrFrameDiffUnion &) FLATBUFFERS_NOEXCEPT;
  FrameOrFrameDiffUnion &operator=(const FrameOrFrameDiffUnion &u) FLATBUFFERS_NOEXCEPT
    { FrameOrFrameDiffUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  FrameOrFrameDiffUnion &operator=(FrameOrFrameDiffUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~FrameOrFrameDiffUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = FrameOrFrameDiffTraits<typename T::TableType>::enum_value;
    if (type != FrameOrFrameDiff::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, FrameOrFrameDiff type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  FrameT *AsFrame() {
    return type == FrameOrFrameDiff::Frame ?
      reinterpret_cast<FrameT *>(value) : nullptr;
  }
  const FrameT *AsFrame() const {
    return type == FrameOrFrameDiff::Frame ?
      reinterpret_cast<const FrameT *>(value) : nullptr;
  }
  FrameDiffT *AsFrameDiff() {
    return type == FrameOrFrameDiff::FrameDiff ?
      reinterpret_cast<FrameDiffT *>(value) : nullptr;
  }
  const FrameDiffT *AsFrameDiff() const {
    return type == FrameOrFrameDiff::FrameDiff ?
      reinterpret_cast<const FrameDiffT *>(value) : nullptr;
  }
};

bool VerifyFrameOrFrameDiff(flatbuffers::Verifier &verifier, const void *obj, FrameOrFrameDiff type);
bool VerifyFrameOrFrameDiffVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AnyMessage : uint8_t {
  NONE = 0,
  HandshakeClient = 1,
  Commands = 2,
  HandshakeServer = 3,
  FrameState = 4,
  PlayerLeft = 5,
  EndGame = 6,
  Error = 7,
  MIN = NONE,
  MAX = Error
};

inline AnyMessage (&EnumValuesAnyMessage())[8] {
  static AnyMessage values[] = {
    AnyMessage::NONE,
    AnyMessage::HandshakeClient,
    AnyMessage::Commands,
    AnyMessage::HandshakeServer,
    AnyMessage::FrameState,
    AnyMessage::PlayerLeft,
    AnyMessage::EndGame,
    AnyMessage::Error
  };
  return values;
}

inline const char **EnumNamesAnyMessage() {
  static const char *names[] = {
    "NONE",
    "HandshakeClient",
    "Commands",
    "HandshakeServer",
    "FrameState",
    "PlayerLeft",
    "EndGame",
    "Error",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyMessage(AnyMessage e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAnyMessage()[index];
}

template<typename T> struct AnyMessageTraits {
  static const AnyMessage enum_value = AnyMessage::NONE;
};

template<> struct AnyMessageTraits<HandshakeClient> {
  static const AnyMessage enum_value = AnyMessage::HandshakeClient;
};

template<> struct AnyMessageTraits<Commands> {
  static const AnyMessage enum_value = AnyMessage::Commands;
};

template<> struct AnyMessageTraits<HandshakeServer> {
  static const AnyMessage enum_value = AnyMessage::HandshakeServer;
};

template<> struct AnyMessageTraits<FrameState> {
  static const AnyMessage enum_value = AnyMessage::FrameState;
};

template<> struct AnyMessageTraits<PlayerLeft> {
  static const AnyMessage enum_value = AnyMessage::PlayerLeft;
};

template<> struct AnyMessageTraits<EndGame> {
  static const AnyMessage enum_value = AnyMessage::EndGame;
};

template<> struct AnyMessageTraits<Error> {
  static const AnyMessage enum_value = AnyMessage::Error;
};

struct AnyMessageUnion {
  AnyMessage type;
  void *value;

  AnyMessageUnion() : type(AnyMessage::NONE), value(nullptr) {}
  AnyMessageUnion(AnyMessageUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AnyMessage::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AnyMessageUnion(const AnyMessageUnion &) FLATBUFFERS_NOEXCEPT;
  AnyMessageUnion &operator=(const AnyMessageUnion &u) FLATBUFFERS_NOEXCEPT
    { AnyMessageUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AnyMessageUnion &operator=(AnyMessageUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AnyMessageUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = AnyMessageTraits<typename T::TableType>::enum_value;
    if (type != AnyMessage::NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, AnyMessage type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  HandshakeClientT *AsHandshakeClient() {
    return type == AnyMessage::HandshakeClient ?
      reinterpret_cast<HandshakeClientT *>(value) : nullptr;
  }
  const HandshakeClientT *AsHandshakeClient() const {
    return type == AnyMessage::HandshakeClient ?
      reinterpret_cast<const HandshakeClientT *>(value) : nullptr;
  }
  CommandsT *AsCommands() {
    return type == AnyMessage::Commands ?
      reinterpret_cast<CommandsT *>(value) : nullptr;
  }
  const CommandsT *AsCommands() const {
    return type == AnyMessage::Commands ?
      reinterpret_cast<const CommandsT *>(value) : nullptr;
  }
  HandshakeServerT *AsHandshakeServer() {
    return type == AnyMessage::HandshakeServer ?
      reinterpret_cast<HandshakeServerT *>(value) : nullptr;
  }
  const HandshakeServerT *AsHandshakeServer() const {
    return type == AnyMessage::HandshakeServer ?
      reinterpret_cast<const HandshakeServerT *>(value) : nullptr;
  }
  FrameStateT *AsFrameState() {
    return type == AnyMessage::FrameState ?
      reinterpret_cast<FrameStateT *>(value) : nullptr;
  }
  const FrameStateT *AsFrameState() const {
    return type == AnyMessage::FrameState ?
      reinterpret_cast<const FrameStateT *>(value) : nullptr;
  }
  PlayerLeftT *AsPlayerLeft() {
    return type == AnyMessage::PlayerLeft ?
      reinterpret_cast<PlayerLeftT *>(value) : nullptr;
  }
  const PlayerLeftT *AsPlayerLeft() const {
    return type == AnyMessage::PlayerLeft ?
      reinterpret_cast<const PlayerLeftT *>(value) : nullptr;
  }
  EndGameT *AsEndGame() {
    return type == AnyMessage::EndGame ?
      reinterpret_cast<EndGameT *>(value) : nullptr;
  }
  const EndGameT *AsEndGame() const {
    return type == AnyMessage::EndGame ?
      reinterpret_cast<const EndGameT *>(value) : nullptr;
  }
  ErrorT *AsError() {
    return type == AnyMessage::Error ?
      reinterpret_cast<ErrorT *>(value) : nullptr;
  }
  const ErrorT *AsError() const {
    return type == AnyMessage::Error ?
      reinterpret_cast<const ErrorT *>(value) : nullptr;
  }
};

bool VerifyAnyMessage(flatbuffers::Verifier &verifier, const void *obj, AnyMessage type);
bool VerifyAnyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Vec2() {
    memset(this, 0, sizeof(Vec2));
  }
  Vec2(const Vec2 &_o) {
    memcpy(this, &_o, sizeof(Vec2));
  }
  Vec2(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(int32_t _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(int32_t _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
};
STRUCT_END(Vec2, 8);

struct CommandT : public flatbuffers::NativeTable {
  typedef Command TableType;
  int32_t code;
  std::vector<int32_t> args;
  std::string str;
  CommandT()
      : code(0) {
  }
};

struct Command FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommandT NativeTableType;
  enum {
    VT_CODE = 4,
    VT_ARGS = 6,
    VT_STR = 8
  };
  int32_t code() const {
    return GetField<int32_t>(VT_CODE, 0);
  }
  bool mutate_code(int32_t _code) {
    return SetField<int32_t>(VT_CODE, _code, 0);
  }
  const flatbuffers::Vector<int32_t> *args() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ARGS);
  }
  flatbuffers::Vector<int32_t> *mutable_args() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ARGS);
  }
  const flatbuffers::String *str() const {
    return GetPointer<const flatbuffers::String *>(VT_STR);
  }
  flatbuffers::String *mutable_str() {
    return GetPointer<flatbuffers::String *>(VT_STR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.Verify(args()) &&
           VerifyOffset(verifier, VT_STR) &&
           verifier.Verify(str()) &&
           verifier.EndTable();
  }
  CommandT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CommandT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Command> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int32_t code) {
    fbb_.AddElement<int32_t>(Command::VT_CODE, code, 0);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<int32_t>> args) {
    fbb_.AddOffset(Command::VT_ARGS, args);
  }
  void add_str(flatbuffers::Offset<flatbuffers::String> str) {
    fbb_.AddOffset(Command::VT_STR, str);
  }
  explicit CommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandBuilder &operator=(const CommandBuilder &);
  flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline flatbuffers::Offset<Command> CreateCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> args = 0,
    flatbuffers::Offset<flatbuffers::String> str = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_str(str);
  builder_.add_args(args);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Command> CreateCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t code = 0,
    const std::vector<int32_t> *args = nullptr,
    const char *str = nullptr) {
  return torchcraft::fbs::CreateCommand(
      _fbb,
      code,
      args ? _fbb.CreateVector<int32_t>(*args) : 0,
      str ? _fbb.CreateString(str) : 0);
}

flatbuffers::Offset<Command> CreateCommand(flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerT : public flatbuffers::NativeTable {
  typedef Player TableType;
  int32_t id;
  int32_t race;
  std::string name;
  bool is_enemy;
  PlayerT()
      : id(0),
        race(0),
        is_enemy(false) {
  }
};

struct Player FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerT NativeTableType;
  enum {
    VT_ID = 4,
    VT_RACE = 6,
    VT_NAME = 8,
    VT_IS_ENEMY = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool mutate_id(int32_t _id) {
    return SetField<int32_t>(VT_ID, _id, 0);
  }
  int32_t race() const {
    return GetField<int32_t>(VT_RACE, 0);
  }
  bool mutate_race(int32_t _race) {
    return SetField<int32_t>(VT_RACE, _race, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  bool is_enemy() const {
    return GetField<uint8_t>(VT_IS_ENEMY, 0) != 0;
  }
  bool mutate_is_enemy(bool _is_enemy) {
    return SetField<uint8_t>(VT_IS_ENEMY, static_cast<uint8_t>(_is_enemy), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_RACE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_ENEMY) &&
           verifier.EndTable();
  }
  PlayerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Player> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Player::VT_ID, id, 0);
  }
  void add_race(int32_t race) {
    fbb_.AddElement<int32_t>(Player::VT_RACE, race, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Player::VT_NAME, name);
  }
  void add_is_enemy(bool is_enemy) {
    fbb_.AddElement<uint8_t>(Player::VT_IS_ENEMY, static_cast<uint8_t>(is_enemy), 0);
  }
  explicit PlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerBuilder &operator=(const PlayerBuilder &);
  flatbuffers::Offset<Player> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Player>(end);
    return o;
  }
};

inline flatbuffers::Offset<Player> CreatePlayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t race = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool is_enemy = false) {
  PlayerBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_race(race);
  builder_.add_id(id);
  builder_.add_is_enemy(is_enemy);
  return builder_.Finish();
}

inline flatbuffers::Offset<Player> CreatePlayerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t race = 0,
    const char *name = nullptr,
    bool is_enemy = false) {
  return torchcraft::fbs::CreatePlayer(
      _fbb,
      id,
      race,
      name ? _fbb.CreateString(name) : 0,
      is_enemy);
}

flatbuffers::Offset<Player> CreatePlayer(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HandshakeClientT : public flatbuffers::NativeTable {
  typedef HandshakeClient TableType;
  int32_t protocol;
  std::string map;
  std::unique_ptr<Vec2> window_size;
  std::unique_ptr<Vec2> window_pos;
  bool micro_mode;
  HandshakeClientT()
      : protocol(0),
        micro_mode(false) {
  }
};

struct HandshakeClient FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeClientT NativeTableType;
  enum {
    VT_PROTOCOL = 4,
    VT_MAP = 6,
    VT_WINDOW_SIZE = 8,
    VT_WINDOW_POS = 10,
    VT_MICRO_MODE = 12
  };
  int32_t protocol() const {
    return GetField<int32_t>(VT_PROTOCOL, 0);
  }
  bool mutate_protocol(int32_t _protocol) {
    return SetField<int32_t>(VT_PROTOCOL, _protocol, 0);
  }
  const flatbuffers::String *map() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP);
  }
  flatbuffers::String *mutable_map() {
    return GetPointer<flatbuffers::String *>(VT_MAP);
  }
  const Vec2 *window_size() const {
    return GetStruct<const Vec2 *>(VT_WINDOW_SIZE);
  }
  Vec2 *mutable_window_size() {
    return GetStruct<Vec2 *>(VT_WINDOW_SIZE);
  }
  const Vec2 *window_pos() const {
    return GetStruct<const Vec2 *>(VT_WINDOW_POS);
  }
  Vec2 *mutable_window_pos() {
    return GetStruct<Vec2 *>(VT_WINDOW_POS);
  }
  bool micro_mode() const {
    return GetField<uint8_t>(VT_MICRO_MODE, 0) != 0;
  }
  bool mutate_micro_mode(bool _micro_mode) {
    return SetField<uint8_t>(VT_MICRO_MODE, static_cast<uint8_t>(_micro_mode), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PROTOCOL) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.Verify(map()) &&
           VerifyField<Vec2>(verifier, VT_WINDOW_SIZE) &&
           VerifyField<Vec2>(verifier, VT_WINDOW_POS) &&
           VerifyField<uint8_t>(verifier, VT_MICRO_MODE) &&
           verifier.EndTable();
  }
  HandshakeClientT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HandshakeClientT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HandshakeClient> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeClientT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HandshakeClientBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol(int32_t protocol) {
    fbb_.AddElement<int32_t>(HandshakeClient::VT_PROTOCOL, protocol, 0);
  }
  void add_map(flatbuffers::Offset<flatbuffers::String> map) {
    fbb_.AddOffset(HandshakeClient::VT_MAP, map);
  }
  void add_window_size(const Vec2 *window_size) {
    fbb_.AddStruct(HandshakeClient::VT_WINDOW_SIZE, window_size);
  }
  void add_window_pos(const Vec2 *window_pos) {
    fbb_.AddStruct(HandshakeClient::VT_WINDOW_POS, window_pos);
  }
  void add_micro_mode(bool micro_mode) {
    fbb_.AddElement<uint8_t>(HandshakeClient::VT_MICRO_MODE, static_cast<uint8_t>(micro_mode), 0);
  }
  explicit HandshakeClientBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HandshakeClientBuilder &operator=(const HandshakeClientBuilder &);
  flatbuffers::Offset<HandshakeClient> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandshakeClient>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandshakeClient> CreateHandshakeClient(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t protocol = 0,
    flatbuffers::Offset<flatbuffers::String> map = 0,
    const Vec2 *window_size = 0,
    const Vec2 *window_pos = 0,
    bool micro_mode = false) {
  HandshakeClientBuilder builder_(_fbb);
  builder_.add_window_pos(window_pos);
  builder_.add_window_size(window_size);
  builder_.add_map(map);
  builder_.add_protocol(protocol);
  builder_.add_micro_mode(micro_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandshakeClient> CreateHandshakeClientDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t protocol = 0,
    const char *map = nullptr,
    const Vec2 *window_size = 0,
    const Vec2 *window_pos = 0,
    bool micro_mode = false) {
  return torchcraft::fbs::CreateHandshakeClient(
      _fbb,
      protocol,
      map ? _fbb.CreateString(map) : 0,
      window_size,
      window_pos,
      micro_mode);
}

flatbuffers::Offset<HandshakeClient> CreateHandshakeClient(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeClientT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HandshakeServerT : public flatbuffers::NativeTable {
  typedef HandshakeServer TableType;
  int32_t lag_frames;
  std::unique_ptr<Vec2> map_size;
  std::vector<uint8_t> ground_height_data;
  std::vector<uint8_t> walkable_data;
  std::string map_name;
  bool is_replay;
  int32_t player_id;
  int32_t neutral_id;
  int32_t battle_frame_count;
  std::vector<uint8_t> buildable_data;
  std::vector<Vec2> start_locations;
  std::vector<std::unique_ptr<PlayerT>> players;
  HandshakeServerT()
      : lag_frames(0),
        is_replay(false),
        player_id(0),
        neutral_id(0),
        battle_frame_count(0) {
  }
};

struct HandshakeServer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeServerT NativeTableType;
  enum {
    VT_LAG_FRAMES = 4,
    VT_MAP_SIZE = 6,
    VT_GROUND_HEIGHT_DATA = 8,
    VT_WALKABLE_DATA = 10,
    VT_MAP_NAME = 12,
    VT_IS_REPLAY = 14,
    VT_PLAYER_ID = 16,
    VT_NEUTRAL_ID = 18,
    VT_BATTLE_FRAME_COUNT = 20,
    VT_BUILDABLE_DATA = 22,
    VT_START_LOCATIONS = 24,
    VT_PLAYERS = 26
  };
  int32_t lag_frames() const {
    return GetField<int32_t>(VT_LAG_FRAMES, 0);
  }
  bool mutate_lag_frames(int32_t _lag_frames) {
    return SetField<int32_t>(VT_LAG_FRAMES, _lag_frames, 0);
  }
  const Vec2 *map_size() const {
    return GetStruct<const Vec2 *>(VT_MAP_SIZE);
  }
  Vec2 *mutable_map_size() {
    return GetStruct<Vec2 *>(VT_MAP_SIZE);
  }
  const flatbuffers::Vector<uint8_t> *ground_height_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_GROUND_HEIGHT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_ground_height_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_GROUND_HEIGHT_DATA);
  }
  const flatbuffers::Vector<uint8_t> *walkable_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_WALKABLE_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_walkable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_WALKABLE_DATA);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  flatbuffers::String *mutable_map_name() {
    return GetPointer<flatbuffers::String *>(VT_MAP_NAME);
  }
  bool is_replay() const {
    return GetField<uint8_t>(VT_IS_REPLAY, 0) != 0;
  }
  bool mutate_is_replay(bool _is_replay) {
    return SetField<uint8_t>(VT_IS_REPLAY, static_cast<uint8_t>(_is_replay), 0);
  }
  int32_t player_id() const {
    return GetField<int32_t>(VT_PLAYER_ID, 0);
  }
  bool mutate_player_id(int32_t _player_id) {
    return SetField<int32_t>(VT_PLAYER_ID, _player_id, 0);
  }
  int32_t neutral_id() const {
    return GetField<int32_t>(VT_NEUTRAL_ID, 0);
  }
  bool mutate_neutral_id(int32_t _neutral_id) {
    return SetField<int32_t>(VT_NEUTRAL_ID, _neutral_id, 0);
  }
  int32_t battle_frame_count() const {
    return GetField<int32_t>(VT_BATTLE_FRAME_COUNT, 0);
  }
  bool mutate_battle_frame_count(int32_t _battle_frame_count) {
    return SetField<int32_t>(VT_BATTLE_FRAME_COUNT, _battle_frame_count, 0);
  }
  const flatbuffers::Vector<uint8_t> *buildable_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUILDABLE_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_buildable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BUILDABLE_DATA);
  }
  const flatbuffers::Vector<const Vec2 *> *start_locations() const {
    return GetPointer<const flatbuffers::Vector<const Vec2 *> *>(VT_START_LOCATIONS);
  }
  flatbuffers::Vector<const Vec2 *> *mutable_start_locations() {
    return GetPointer<flatbuffers::Vector<const Vec2 *> *>(VT_START_LOCATIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Player>> *players() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Player>> *>(VT_PLAYERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Player>> *mutable_players() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Player>> *>(VT_PLAYERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LAG_FRAMES) &&
           VerifyField<Vec2>(verifier, VT_MAP_SIZE) &&
           VerifyOffset(verifier, VT_GROUND_HEIGHT_DATA) &&
           verifier.Verify(ground_height_data()) &&
           VerifyOffset(verifier, VT_WALKABLE_DATA) &&
           verifier.Verify(walkable_data()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.Verify(map_name()) &&
           VerifyField<uint8_t>(verifier, VT_IS_REPLAY) &&
           VerifyField<int32_t>(verifier, VT_PLAYER_ID) &&
           VerifyField<int32_t>(verifier, VT_NEUTRAL_ID) &&
           VerifyField<int32_t>(verifier, VT_BATTLE_FRAME_COUNT) &&
           VerifyOffset(verifier, VT_BUILDABLE_DATA) &&
           verifier.Verify(buildable_data()) &&
           VerifyOffset(verifier, VT_START_LOCATIONS) &&
           verifier.Verify(start_locations()) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.Verify(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           verifier.EndTable();
  }
  HandshakeServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HandshakeServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HandshakeServer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HandshakeServerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lag_frames(int32_t lag_frames) {
    fbb_.AddElement<int32_t>(HandshakeServer::VT_LAG_FRAMES, lag_frames, 0);
  }
  void add_map_size(const Vec2 *map_size) {
    fbb_.AddStruct(HandshakeServer::VT_MAP_SIZE, map_size);
  }
  void add_ground_height_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ground_height_data) {
    fbb_.AddOffset(HandshakeServer::VT_GROUND_HEIGHT_DATA, ground_height_data);
  }
  void add_walkable_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> walkable_data) {
    fbb_.AddOffset(HandshakeServer::VT_WALKABLE_DATA, walkable_data);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(HandshakeServer::VT_MAP_NAME, map_name);
  }
  void add_is_replay(bool is_replay) {
    fbb_.AddElement<uint8_t>(HandshakeServer::VT_IS_REPLAY, static_cast<uint8_t>(is_replay), 0);
  }
  void add_player_id(int32_t player_id) {
    fbb_.AddElement<int32_t>(HandshakeServer::VT_PLAYER_ID, player_id, 0);
  }
  void add_neutral_id(int32_t neutral_id) {
    fbb_.AddElement<int32_t>(HandshakeServer::VT_NEUTRAL_ID, neutral_id, 0);
  }
  void add_battle_frame_count(int32_t battle_frame_count) {
    fbb_.AddElement<int32_t>(HandshakeServer::VT_BATTLE_FRAME_COUNT, battle_frame_count, 0);
  }
  void add_buildable_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buildable_data) {
    fbb_.AddOffset(HandshakeServer::VT_BUILDABLE_DATA, buildable_data);
  }
  void add_start_locations(flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> start_locations) {
    fbb_.AddOffset(HandshakeServer::VT_START_LOCATIONS, start_locations);
  }
  void add_players(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Player>>> players) {
    fbb_.AddOffset(HandshakeServer::VT_PLAYERS, players);
  }
  explicit HandshakeServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HandshakeServerBuilder &operator=(const HandshakeServerBuilder &);
  flatbuffers::Offset<HandshakeServer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandshakeServer>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandshakeServer> CreateHandshakeServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lag_frames = 0,
    const Vec2 *map_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> ground_height_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> walkable_data = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0,
    bool is_replay = false,
    int32_t player_id = 0,
    int32_t neutral_id = 0,
    int32_t battle_frame_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buildable_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> start_locations = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Player>>> players = 0) {
  HandshakeServerBuilder builder_(_fbb);
  builder_.add_players(players);
  builder_.add_start_locations(start_locations);
  builder_.add_buildable_data(buildable_data);
  builder_.add_battle_frame_count(battle_frame_count);
  builder_.add_neutral_id(neutral_id);
  builder_.add_player_id(player_id);
  builder_.add_map_name(map_name);
  builder_.add_walkable_data(walkable_data);
  builder_.add_ground_height_data(ground_height_data);
  builder_.add_map_size(map_size);
  builder_.add_lag_frames(lag_frames);
  builder_.add_is_replay(is_replay);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandshakeServer> CreateHandshakeServerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t lag_frames = 0,
    const Vec2 *map_size = 0,
    const std::vector<uint8_t> *ground_height_data = nullptr,
    const std::vector<uint8_t> *walkable_data = nullptr,
    const char *map_name = nullptr,
    bool is_replay = false,
    int32_t player_id = 0,
    int32_t neutral_id = 0,
    int32_t battle_frame_count = 0,
    const std::vector<uint8_t> *buildable_data = nullptr,
    const std::vector<const Vec2 *> *start_locations = nullptr,
    const std::vector<flatbuffers::Offset<Player>> *players = nullptr) {
  return torchcraft::fbs::CreateHandshakeServer(
      _fbb,
      lag_frames,
      map_size,
      ground_height_data ? _fbb.CreateVector<uint8_t>(*ground_height_data) : 0,
      walkable_data ? _fbb.CreateVector<uint8_t>(*walkable_data) : 0,
      map_name ? _fbb.CreateString(map_name) : 0,
      is_replay,
      player_id,
      neutral_id,
      battle_frame_count,
      buildable_data ? _fbb.CreateVector<uint8_t>(*buildable_data) : 0,
      start_locations ? _fbb.CreateVector<const Vec2 *>(*start_locations) : 0,
      players ? _fbb.CreateVector<flatbuffers::Offset<Player>>(*players) : 0);
}

flatbuffers::Offset<HandshakeServer> CreateHandshakeServer(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CommandsT : public flatbuffers::NativeTable {
  typedef Commands TableType;
  std::vector<std::unique_ptr<CommandT>> commands;
  CommandsT() {
  }
};

struct Commands FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommandsT NativeTableType;
  enum {
    VT_COMMANDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Command>> *commands() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Command>> *>(VT_COMMANDS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Command>> *mutable_commands() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Command>> *>(VT_COMMANDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.Verify(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           verifier.EndTable();
  }
  CommandsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CommandsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Commands> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CommandsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CommandsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Command>>> commands) {
    fbb_.AddOffset(Commands::VT_COMMANDS, commands);
  }
  explicit CommandsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandsBuilder &operator=(const CommandsBuilder &);
  flatbuffers::Offset<Commands> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Commands>(end);
    return o;
  }
};

inline flatbuffers::Offset<Commands> CreateCommands(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Command>>> commands = 0) {
  CommandsBuilder builder_(_fbb);
  builder_.add_commands(commands);
  return builder_.Finish();
}

inline flatbuffers::Offset<Commands> CreateCommandsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Command>> *commands = nullptr) {
  return torchcraft::fbs::CreateCommands(
      _fbb,
      commands ? _fbb.CreateVector<flatbuffers::Offset<Command>>(*commands) : 0);
}

flatbuffers::Offset<Commands> CreateCommands(flatbuffers::FlatBufferBuilder &_fbb, const CommandsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameStateT : public flatbuffers::NativeTable {
  typedef FrameState TableType;
  FrameOrFrameDiffUnion frameOrFrameDiff;
  std::vector<int32_t> deaths;
  int32_t frame_from_bwapi;
  int32_t battle_frame_count;
  std::vector<int8_t> commands_status;
  std::string img_mode;
  std::unique_ptr<Vec2> screen_position;
  std::vector<uint8_t> visibility;
  std::unique_ptr<Vec2> visibility_size;
  std::vector<uint8_t> img_data;
  std::unique_ptr<Vec2> img_size;
  FrameStateT()
      : frame_from_bwapi(0),
        battle_frame_count(0) {
  }
};

struct FrameState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameStateT NativeTableType;
  enum {
    VT_FRAMEORFRAMEDIFF_TYPE = 4,
    VT_FRAMEORFRAMEDIFF = 6,
    VT_DEATHS = 8,
    VT_FRAME_FROM_BWAPI = 10,
    VT_BATTLE_FRAME_COUNT = 12,
    VT_COMMANDS_STATUS = 14,
    VT_IMG_MODE = 16,
    VT_SCREEN_POSITION = 18,
    VT_VISIBILITY = 20,
    VT_VISIBILITY_SIZE = 22,
    VT_IMG_DATA = 24,
    VT_IMG_SIZE = 26
  };
  FrameOrFrameDiff frameOrFrameDiff_type() const {
    return static_cast<FrameOrFrameDiff>(GetField<uint8_t>(VT_FRAMEORFRAMEDIFF_TYPE, 0));
  }
  bool mutate_frameOrFrameDiff_type(FrameOrFrameDiff _frameOrFrameDiff_type) {
    return SetField<uint8_t>(VT_FRAMEORFRAMEDIFF_TYPE, static_cast<uint8_t>(_frameOrFrameDiff_type), 0);
  }
  const void *frameOrFrameDiff() const {
    return GetPointer<const void *>(VT_FRAMEORFRAMEDIFF);
  }
  template<typename T> const T *frameOrFrameDiff_as() const;
  const Frame *frameOrFrameDiff_as_Frame() const {
    return frameOrFrameDiff_type() == FrameOrFrameDiff::Frame ? static_cast<const Frame *>(frameOrFrameDiff()) : nullptr;
  }
  const FrameDiff *frameOrFrameDiff_as_FrameDiff() const {
    return frameOrFrameDiff_type() == FrameOrFrameDiff::FrameDiff ? static_cast<const FrameDiff *>(frameOrFrameDiff()) : nullptr;
  }
  void *mutable_frameOrFrameDiff() {
    return GetPointer<void *>(VT_FRAMEORFRAMEDIFF);
  }
  const flatbuffers::Vector<int32_t> *deaths() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DEATHS);
  }
  flatbuffers::Vector<int32_t> *mutable_deaths() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_DEATHS);
  }
  int32_t frame_from_bwapi() const {
    return GetField<int32_t>(VT_FRAME_FROM_BWAPI, 0);
  }
  bool mutate_frame_from_bwapi(int32_t _frame_from_bwapi) {
    return SetField<int32_t>(VT_FRAME_FROM_BWAPI, _frame_from_bwapi, 0);
  }
  int32_t battle_frame_count() const {
    return GetField<int32_t>(VT_BATTLE_FRAME_COUNT, 0);
  }
  bool mutate_battle_frame_count(int32_t _battle_frame_count) {
    return SetField<int32_t>(VT_BATTLE_FRAME_COUNT, _battle_frame_count, 0);
  }
  const flatbuffers::Vector<int8_t> *commands_status() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_COMMANDS_STATUS);
  }
  flatbuffers::Vector<int8_t> *mutable_commands_status() {
    return GetPointer<flatbuffers::Vector<int8_t> *>(VT_COMMANDS_STATUS);
  }
  const flatbuffers::String *img_mode() const {
    return GetPointer<const flatbuffers::String *>(VT_IMG_MODE);
  }
  flatbuffers::String *mutable_img_mode() {
    return GetPointer<flatbuffers::String *>(VT_IMG_MODE);
  }
  const Vec2 *screen_position() const {
    return GetStruct<const Vec2 *>(VT_SCREEN_POSITION);
  }
  Vec2 *mutable_screen_position() {
    return GetStruct<Vec2 *>(VT_SCREEN_POSITION);
  }
  const flatbuffers::Vector<uint8_t> *visibility() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VISIBILITY);
  }
  flatbuffers::Vector<uint8_t> *mutable_visibility() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_VISIBILITY);
  }
  const Vec2 *visibility_size() const {
    return GetStruct<const Vec2 *>(VT_VISIBILITY_SIZE);
  }
  Vec2 *mutable_visibility_size() {
    return GetStruct<Vec2 *>(VT_VISIBILITY_SIZE);
  }
  const flatbuffers::Vector<uint8_t> *img_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_IMG_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_img_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_IMG_DATA);
  }
  const Vec2 *img_size() const {
    return GetStruct<const Vec2 *>(VT_IMG_SIZE);
  }
  Vec2 *mutable_img_size() {
    return GetStruct<Vec2 *>(VT_IMG_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FRAMEORFRAMEDIFF_TYPE) &&
           VerifyOffset(verifier, VT_FRAMEORFRAMEDIFF) &&
           VerifyFrameOrFrameDiff(verifier, frameOrFrameDiff(), frameOrFrameDiff_type()) &&
           VerifyOffset(verifier, VT_DEATHS) &&
           verifier.Verify(deaths()) &&
           VerifyField<int32_t>(verifier, VT_FRAME_FROM_BWAPI) &&
           VerifyField<int32_t>(verifier, VT_BATTLE_FRAME_COUNT) &&
           VerifyOffset(verifier, VT_COMMANDS_STATUS) &&
           verifier.Verify(commands_status()) &&
           VerifyOffset(verifier, VT_IMG_MODE) &&
           verifier.Verify(img_mode()) &&
           VerifyField<Vec2>(verifier, VT_SCREEN_POSITION) &&
           VerifyOffset(verifier, VT_VISIBILITY) &&
           verifier.Verify(visibility()) &&
           VerifyField<Vec2>(verifier, VT_VISIBILITY_SIZE) &&
           VerifyOffset(verifier, VT_IMG_DATA) &&
           verifier.Verify(img_data()) &&
           VerifyField<Vec2>(verifier, VT_IMG_SIZE) &&
           verifier.EndTable();
  }
  FrameStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FrameState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Frame *FrameState::frameOrFrameDiff_as<Frame>() const {
  return frameOrFrameDiff_as_Frame();
}

template<> inline const FrameDiff *FrameState::frameOrFrameDiff_as<FrameDiff>() const {
  return frameOrFrameDiff_as_FrameDiff();
}

struct FrameStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frameOrFrameDiff_type(FrameOrFrameDiff frameOrFrameDiff_type) {
    fbb_.AddElement<uint8_t>(FrameState::VT_FRAMEORFRAMEDIFF_TYPE, static_cast<uint8_t>(frameOrFrameDiff_type), 0);
  }
  void add_frameOrFrameDiff(flatbuffers::Offset<void> frameOrFrameDiff) {
    fbb_.AddOffset(FrameState::VT_FRAMEORFRAMEDIFF, frameOrFrameDiff);
  }
  void add_deaths(flatbuffers::Offset<flatbuffers::Vector<int32_t>> deaths) {
    fbb_.AddOffset(FrameState::VT_DEATHS, deaths);
  }
  void add_frame_from_bwapi(int32_t frame_from_bwapi) {
    fbb_.AddElement<int32_t>(FrameState::VT_FRAME_FROM_BWAPI, frame_from_bwapi, 0);
  }
  void add_battle_frame_count(int32_t battle_frame_count) {
    fbb_.AddElement<int32_t>(FrameState::VT_BATTLE_FRAME_COUNT, battle_frame_count, 0);
  }
  void add_commands_status(flatbuffers::Offset<flatbuffers::Vector<int8_t>> commands_status) {
    fbb_.AddOffset(FrameState::VT_COMMANDS_STATUS, commands_status);
  }
  void add_img_mode(flatbuffers::Offset<flatbuffers::String> img_mode) {
    fbb_.AddOffset(FrameState::VT_IMG_MODE, img_mode);
  }
  void add_screen_position(const Vec2 *screen_position) {
    fbb_.AddStruct(FrameState::VT_SCREEN_POSITION, screen_position);
  }
  void add_visibility(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> visibility) {
    fbb_.AddOffset(FrameState::VT_VISIBILITY, visibility);
  }
  void add_visibility_size(const Vec2 *visibility_size) {
    fbb_.AddStruct(FrameState::VT_VISIBILITY_SIZE, visibility_size);
  }
  void add_img_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> img_data) {
    fbb_.AddOffset(FrameState::VT_IMG_DATA, img_data);
  }
  void add_img_size(const Vec2 *img_size) {
    fbb_.AddStruct(FrameState::VT_IMG_SIZE, img_size);
  }
  explicit FrameStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameStateBuilder &operator=(const FrameStateBuilder &);
  flatbuffers::Offset<FrameState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FrameState>(end);
    return o;
  }
};

inline flatbuffers::Offset<FrameState> CreateFrameState(
    flatbuffers::FlatBufferBuilder &_fbb,
    FrameOrFrameDiff frameOrFrameDiff_type = FrameOrFrameDiff::NONE,
    flatbuffers::Offset<void> frameOrFrameDiff = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> deaths = 0,
    int32_t frame_from_bwapi = 0,
    int32_t battle_frame_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> commands_status = 0,
    flatbuffers::Offset<flatbuffers::String> img_mode = 0,
    const Vec2 *screen_position = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> visibility = 0,
    const Vec2 *visibility_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> img_data = 0,
    const Vec2 *img_size = 0) {
  FrameStateBuilder builder_(_fbb);
  builder_.add_img_size(img_size);
  builder_.add_img_data(img_data);
  builder_.add_visibility_size(visibility_size);
  builder_.add_visibility(visibility);
  builder_.add_screen_position(screen_position);
  builder_.add_img_mode(img_mode);
  builder_.add_commands_status(commands_status);
  builder_.add_battle_frame_count(battle_frame_count);
  builder_.add_frame_from_bwapi(frame_from_bwapi);
  builder_.add_deaths(deaths);
  builder_.add_frameOrFrameDiff(frameOrFrameDiff);
  builder_.add_frameOrFrameDiff_type(frameOrFrameDiff_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FrameState> CreateFrameStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    FrameOrFrameDiff frameOrFrameDiff_type = FrameOrFrameDiff::NONE,
    flatbuffers::Offset<void> frameOrFrameDiff = 0,
    const std::vector<int32_t> *deaths = nullptr,
    int32_t frame_from_bwapi = 0,
    int32_t battle_frame_count = 0,
    const std::vector<int8_t> *commands_status = nullptr,
    const char *img_mode = nullptr,
    const Vec2 *screen_position = 0,
    const std::vector<uint8_t> *visibility = nullptr,
    const Vec2 *visibility_size = 0,
    const std::vector<uint8_t> *img_data = nullptr,
    const Vec2 *img_size = 0) {
  return torchcraft::fbs::CreateFrameState(
      _fbb,
      frameOrFrameDiff_type,
      frameOrFrameDiff,
      deaths ? _fbb.CreateVector<int32_t>(*deaths) : 0,
      frame_from_bwapi,
      battle_frame_count,
      commands_status ? _fbb.CreateVector<int8_t>(*commands_status) : 0,
      img_mode ? _fbb.CreateString(img_mode) : 0,
      screen_position,
      visibility ? _fbb.CreateVector<uint8_t>(*visibility) : 0,
      visibility_size,
      img_data ? _fbb.CreateVector<uint8_t>(*img_data) : 0,
      img_size);
}

flatbuffers::Offset<FrameState> CreateFrameState(flatbuffers::FlatBufferBuilder &_fbb, const FrameStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerLeftT : public flatbuffers::NativeTable {
  typedef PlayerLeft TableType;
  std::string player_left;
  PlayerLeftT() {
  }
};

struct PlayerLeft FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PlayerLeftT NativeTableType;
  enum {
    VT_PLAYER_LEFT = 4
  };
  const flatbuffers::String *player_left() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYER_LEFT);
  }
  flatbuffers::String *mutable_player_left() {
    return GetPointer<flatbuffers::String *>(VT_PLAYER_LEFT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER_LEFT) &&
           verifier.Verify(player_left()) &&
           verifier.EndTable();
  }
  PlayerLeftT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerLeftT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PlayerLeft> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerLeftT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerLeftBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player_left(flatbuffers::Offset<flatbuffers::String> player_left) {
    fbb_.AddOffset(PlayerLeft::VT_PLAYER_LEFT, player_left);
  }
  explicit PlayerLeftBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerLeftBuilder &operator=(const PlayerLeftBuilder &);
  flatbuffers::Offset<PlayerLeft> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerLeft>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerLeft> CreatePlayerLeft(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> player_left = 0) {
  PlayerLeftBuilder builder_(_fbb);
  builder_.add_player_left(player_left);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerLeft> CreatePlayerLeftDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *player_left = nullptr) {
  return torchcraft::fbs::CreatePlayerLeft(
      _fbb,
      player_left ? _fbb.CreateString(player_left) : 0);
}

flatbuffers::Offset<PlayerLeft> CreatePlayerLeft(flatbuffers::FlatBufferBuilder &_fbb, const PlayerLeftT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EndGameT : public flatbuffers::NativeTable {
  typedef EndGame TableType;
  FrameOrFrameDiffUnion frameOrFrameDiff;
  bool game_won;
  EndGameT()
      : game_won(false) {
  }
};

struct EndGame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EndGameT NativeTableType;
  enum {
    VT_FRAMEORFRAMEDIFF_TYPE = 4,
    VT_FRAMEORFRAMEDIFF = 6,
    VT_GAME_WON = 8
  };
  FrameOrFrameDiff frameOrFrameDiff_type() const {
    return static_cast<FrameOrFrameDiff>(GetField<uint8_t>(VT_FRAMEORFRAMEDIFF_TYPE, 0));
  }
  bool mutate_frameOrFrameDiff_type(FrameOrFrameDiff _frameOrFrameDiff_type) {
    return SetField<uint8_t>(VT_FRAMEORFRAMEDIFF_TYPE, static_cast<uint8_t>(_frameOrFrameDiff_type), 0);
  }
  const void *frameOrFrameDiff() const {
    return GetPointer<const void *>(VT_FRAMEORFRAMEDIFF);
  }
  template<typename T> const T *frameOrFrameDiff_as() const;
  const Frame *frameOrFrameDiff_as_Frame() const {
    return frameOrFrameDiff_type() == FrameOrFrameDiff::Frame ? static_cast<const Frame *>(frameOrFrameDiff()) : nullptr;
  }
  const FrameDiff *frameOrFrameDiff_as_FrameDiff() const {
    return frameOrFrameDiff_type() == FrameOrFrameDiff::FrameDiff ? static_cast<const FrameDiff *>(frameOrFrameDiff()) : nullptr;
  }
  void *mutable_frameOrFrameDiff() {
    return GetPointer<void *>(VT_FRAMEORFRAMEDIFF);
  }
  bool game_won() const {
    return GetField<uint8_t>(VT_GAME_WON, 0) != 0;
  }
  bool mutate_game_won(bool _game_won) {
    return SetField<uint8_t>(VT_GAME_WON, static_cast<uint8_t>(_game_won), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FRAMEORFRAMEDIFF_TYPE) &&
           VerifyOffset(verifier, VT_FRAMEORFRAMEDIFF) &&
           VerifyFrameOrFrameDiff(verifier, frameOrFrameDiff(), frameOrFrameDiff_type()) &&
           VerifyField<uint8_t>(verifier, VT_GAME_WON) &&
           verifier.EndTable();
  }
  EndGameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EndGameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EndGame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndGameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Frame *EndGame::frameOrFrameDiff_as<Frame>() const {
  return frameOrFrameDiff_as_Frame();
}

template<> inline const FrameDiff *EndGame::frameOrFrameDiff_as<FrameDiff>() const {
  return frameOrFrameDiff_as_FrameDiff();
}

struct EndGameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frameOrFrameDiff_type(FrameOrFrameDiff frameOrFrameDiff_type) {
    fbb_.AddElement<uint8_t>(EndGame::VT_FRAMEORFRAMEDIFF_TYPE, static_cast<uint8_t>(frameOrFrameDiff_type), 0);
  }
  void add_frameOrFrameDiff(flatbuffers::Offset<void> frameOrFrameDiff) {
    fbb_.AddOffset(EndGame::VT_FRAMEORFRAMEDIFF, frameOrFrameDiff);
  }
  void add_game_won(bool game_won) {
    fbb_.AddElement<uint8_t>(EndGame::VT_GAME_WON, static_cast<uint8_t>(game_won), 0);
  }
  explicit EndGameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EndGameBuilder &operator=(const EndGameBuilder &);
  flatbuffers::Offset<EndGame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EndGame>(end);
    return o;
  }
};

inline flatbuffers::Offset<EndGame> CreateEndGame(
    flatbuffers::FlatBufferBuilder &_fbb,
    FrameOrFrameDiff frameOrFrameDiff_type = FrameOrFrameDiff::NONE,
    flatbuffers::Offset<void> frameOrFrameDiff = 0,
    bool game_won = false) {
  EndGameBuilder builder_(_fbb);
  builder_.add_frameOrFrameDiff(frameOrFrameDiff);
  builder_.add_game_won(game_won);
  builder_.add_frameOrFrameDiff_type(frameOrFrameDiff_type);
  return builder_.Finish();
}

flatbuffers::Offset<EndGame> CreateEndGame(flatbuffers::FlatBufferBuilder &_fbb, const EndGameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ErrorT : public flatbuffers::NativeTable {
  typedef Error TableType;
  std::string message;
  ErrorT() {
  }
};

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorT NativeTableType;
  enum {
    VT_MESSAGE = 4
  };
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  flatbuffers::String *mutable_message() {
    return GetPointer<flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           verifier.EndTable();
  }
  ErrorT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Error> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ErrorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Error::VT_MESSAGE, message);
  }
  explicit ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorBuilder &operator=(const ErrorBuilder &);
  flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline flatbuffers::Offset<Error> CreateError(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  return torchcraft::fbs::CreateError(
      _fbb,
      message ? _fbb.CreateString(message) : 0);
}

flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageT : public flatbuffers::NativeTable {
  typedef Message TableType;
  AnyMessageUnion msg;
  std::string uid;
  MessageT() {
  }
};

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageT NativeTableType;
  enum {
    VT_MSG_TYPE = 4,
    VT_MSG = 6,
    VT_UID = 8
  };
  AnyMessage msg_type() const {
    return static_cast<AnyMessage>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  bool mutate_msg_type(AnyMessage _msg_type) {
    return SetField<uint8_t>(VT_MSG_TYPE, static_cast<uint8_t>(_msg_type), 0);
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const HandshakeClient *msg_as_HandshakeClient() const {
    return msg_type() == AnyMessage::HandshakeClient ? static_cast<const HandshakeClient *>(msg()) : nullptr;
  }
  const Commands *msg_as_Commands() const {
    return msg_type() == AnyMessage::Commands ? static_cast<const Commands *>(msg()) : nullptr;
  }
  const HandshakeServer *msg_as_HandshakeServer() const {
    return msg_type() == AnyMessage::HandshakeServer ? static_cast<const HandshakeServer *>(msg()) : nullptr;
  }
  const FrameState *msg_as_FrameState() const {
    return msg_type() == AnyMessage::FrameState ? static_cast<const FrameState *>(msg()) : nullptr;
  }
  const PlayerLeft *msg_as_PlayerLeft() const {
    return msg_type() == AnyMessage::PlayerLeft ? static_cast<const PlayerLeft *>(msg()) : nullptr;
  }
  const EndGame *msg_as_EndGame() const {
    return msg_type() == AnyMessage::EndGame ? static_cast<const EndGame *>(msg()) : nullptr;
  }
  const Error *msg_as_Error() const {
    return msg_type() == AnyMessage::Error ? static_cast<const Error *>(msg()) : nullptr;
  }
  void *mutable_msg() {
    return GetPointer<void *>(VT_MSG);
  }
  const flatbuffers::String *uid() const {
    return GetPointer<const flatbuffers::String *>(VT_UID);
  }
  flatbuffers::String *mutable_uid() {
    return GetPointer<flatbuffers::String *>(VT_UID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyAnyMessage(verifier, msg(), msg_type()) &&
           VerifyOffset(verifier, VT_UID) &&
           verifier.Verify(uid()) &&
           verifier.EndTable();
  }
  MessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Message> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const HandshakeClient *Message::msg_as<HandshakeClient>() const {
  return msg_as_HandshakeClient();
}

template<> inline const Commands *Message::msg_as<Commands>() const {
  return msg_as_Commands();
}

template<> inline const HandshakeServer *Message::msg_as<HandshakeServer>() const {
  return msg_as_HandshakeServer();
}

template<> inline const FrameState *Message::msg_as<FrameState>() const {
  return msg_as_FrameState();
}

template<> inline const PlayerLeft *Message::msg_as<PlayerLeft>() const {
  return msg_as_PlayerLeft();
}

template<> inline const EndGame *Message::msg_as<EndGame>() const {
  return msg_as_EndGame();
}

template<> inline const Error *Message::msg_as<Error>() const {
  return msg_as_Error();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(AnyMessage msg_type) {
    fbb_.AddElement<uint8_t>(Message::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(Message::VT_MSG, msg);
  }
  void add_uid(flatbuffers::Offset<flatbuffers::String> uid) {
    fbb_.AddOffset(Message::VT_UID, uid);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    AnyMessage msg_type = AnyMessage::NONE,
    flatbuffers::Offset<void> msg = 0,
    flatbuffers::Offset<flatbuffers::String> uid = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_uid(uid);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    AnyMessage msg_type = AnyMessage::NONE,
    flatbuffers::Offset<void> msg = 0,
    const char *uid = nullptr) {
  return torchcraft::fbs::CreateMessage(
      _fbb,
      msg_type,
      msg,
      uid ? _fbb.CreateString(uid) : 0);
}

flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MapT : public flatbuffers::NativeTable {
  typedef Map TableType;
  int32_t height;
  int32_t width;
  std::vector<uint8_t> data;
  MapT()
      : height(0),
        width(0) {
  }
};

struct Map FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapT NativeTableType;
  enum {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_DATA = 8
  };
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  bool mutate_height(int32_t _height) {
    return SetField<int32_t>(VT_HEIGHT, _height, 0);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  bool mutate_width(int32_t _width) {
    return SetField<int32_t>(VT_WIDTH, _width, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_WIDTH) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
  MapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Map> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(Map::VT_HEIGHT, height, 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(Map::VT_WIDTH, width, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Map::VT_DATA, data);
  }
  explicit MapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapBuilder &operator=(const MapBuilder &);
  flatbuffers::Offset<Map> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Map>(end);
    return o;
  }
};

inline flatbuffers::Offset<Map> CreateMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  MapBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

inline flatbuffers::Offset<Map> CreateMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t height = 0,
    int32_t width = 0,
    const std::vector<uint8_t> *data = nullptr) {
  return torchcraft::fbs::CreateMap(
      _fbb,
      height,
      width,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

flatbuffers::Offset<Map> CreateMap(flatbuffers::FlatBufferBuilder &_fbb, const MapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionT : public flatbuffers::NativeTable {
  typedef Action TableType;
  std::vector<int32_t> action;
  int32_t uid;
  int32_t aid;
  ActionT()
      : uid(0),
        aid(0) {
  }
};

struct Action FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionT NativeTableType;
  enum {
    VT_ACTION = 4,
    VT_UID = 6,
    VT_AID = 8
  };
  const flatbuffers::Vector<int32_t> *action() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ACTION);
  }
  flatbuffers::Vector<int32_t> *mutable_action() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ACTION);
  }
  int32_t uid() const {
    return GetField<int32_t>(VT_UID, 0);
  }
  bool mutate_uid(int32_t _uid) {
    return SetField<int32_t>(VT_UID, _uid, 0);
  }
  int32_t aid() const {
    return GetField<int32_t>(VT_AID, 0);
  }
  bool mutate_aid(int32_t _aid) {
    return SetField<int32_t>(VT_AID, _aid, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.Verify(action()) &&
           VerifyField<int32_t>(verifier, VT_UID) &&
           VerifyField<int32_t>(verifier, VT_AID) &&
           verifier.EndTable();
  }
  ActionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Action> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(flatbuffers::Offset<flatbuffers::Vector<int32_t>> action) {
    fbb_.AddOffset(Action::VT_ACTION, action);
  }
  void add_uid(int32_t uid) {
    fbb_.AddElement<int32_t>(Action::VT_UID, uid, 0);
  }
  void add_aid(int32_t aid) {
    fbb_.AddElement<int32_t>(Action::VT_AID, aid, 0);
  }
  explicit ActionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionBuilder &operator=(const ActionBuilder &);
  flatbuffers::Offset<Action> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Action>(end);
    return o;
  }
};

inline flatbuffers::Offset<Action> CreateAction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> action = 0,
    int32_t uid = 0,
    int32_t aid = 0) {
  ActionBuilder builder_(_fbb);
  builder_.add_aid(aid);
  builder_.add_uid(uid);
  builder_.add_action(action);
  return builder_.Finish();
}

inline flatbuffers::Offset<Action> CreateActionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *action = nullptr,
    int32_t uid = 0,
    int32_t aid = 0) {
  return torchcraft::fbs::CreateAction(
      _fbb,
      action ? _fbb.CreateVector<int32_t>(*action) : 0,
      uid,
      aid);
}

flatbuffers::Offset<Action> CreateAction(flatbuffers::FlatBufferBuilder &_fbb, const ActionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResourcesT : public flatbuffers::NativeTable {
  typedef Resources TableType;
  int32_t ore;
  int32_t gas;
  int32_t used_psi;
  int32_t total_psi;
  int64_t upgrades;
  int64_t upgrades_level;
  int64_t techs;
  ResourcesT()
      : ore(0),
        gas(0),
        used_psi(0),
        total_psi(0),
        upgrades(0),
        upgrades_level(0),
        techs(0) {
  }
};

struct Resources FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResourcesT NativeTableType;
  enum {
    VT_ORE = 4,
    VT_GAS = 6,
    VT_USED_PSI = 8,
    VT_TOTAL_PSI = 10,
    VT_UPGRADES = 12,
    VT_UPGRADES_LEVEL = 14,
    VT_TECHS = 16
  };
  int32_t ore() const {
    return GetField<int32_t>(VT_ORE, 0);
  }
  bool mutate_ore(int32_t _ore) {
    return SetField<int32_t>(VT_ORE, _ore, 0);
  }
  int32_t gas() const {
    return GetField<int32_t>(VT_GAS, 0);
  }
  bool mutate_gas(int32_t _gas) {
    return SetField<int32_t>(VT_GAS, _gas, 0);
  }
  int32_t used_psi() const {
    return GetField<int32_t>(VT_USED_PSI, 0);
  }
  bool mutate_used_psi(int32_t _used_psi) {
    return SetField<int32_t>(VT_USED_PSI, _used_psi, 0);
  }
  int32_t total_psi() const {
    return GetField<int32_t>(VT_TOTAL_PSI, 0);
  }
  bool mutate_total_psi(int32_t _total_psi) {
    return SetField<int32_t>(VT_TOTAL_PSI, _total_psi, 0);
  }
  int64_t upgrades() const {
    return GetField<int64_t>(VT_UPGRADES, 0);
  }
  bool mutate_upgrades(int64_t _upgrades) {
    return SetField<int64_t>(VT_UPGRADES, _upgrades, 0);
  }
  int64_t upgrades_level() const {
    return GetField<int64_t>(VT_UPGRADES_LEVEL, 0);
  }
  bool mutate_upgrades_level(int64_t _upgrades_level) {
    return SetField<int64_t>(VT_UPGRADES_LEVEL, _upgrades_level, 0);
  }
  int64_t techs() const {
    return GetField<int64_t>(VT_TECHS, 0);
  }
  bool mutate_techs(int64_t _techs) {
    return SetField<int64_t>(VT_TECHS, _techs, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ORE) &&
           VerifyField<int32_t>(verifier, VT_GAS) &&
           VerifyField<int32_t>(verifier, VT_USED_PSI) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_PSI) &&
           VerifyField<int64_t>(verifier, VT_UPGRADES) &&
           VerifyField<int64_t>(verifier, VT_UPGRADES_LEVEL) &&
           VerifyField<int64_t>(verifier, VT_TECHS) &&
           verifier.EndTable();
  }
  ResourcesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResourcesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Resources> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResourcesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ore(int32_t ore) {
    fbb_.AddElement<int32_t>(Resources::VT_ORE, ore, 0);
  }
  void add_gas(int32_t gas) {
    fbb_.AddElement<int32_t>(Resources::VT_GAS, gas, 0);
  }
  void add_used_psi(int32_t used_psi) {
    fbb_.AddElement<int32_t>(Resources::VT_USED_PSI, used_psi, 0);
  }
  void add_total_psi(int32_t total_psi) {
    fbb_.AddElement<int32_t>(Resources::VT_TOTAL_PSI, total_psi, 0);
  }
  void add_upgrades(int64_t upgrades) {
    fbb_.AddElement<int64_t>(Resources::VT_UPGRADES, upgrades, 0);
  }
  void add_upgrades_level(int64_t upgrades_level) {
    fbb_.AddElement<int64_t>(Resources::VT_UPGRADES_LEVEL, upgrades_level, 0);
  }
  void add_techs(int64_t techs) {
    fbb_.AddElement<int64_t>(Resources::VT_TECHS, techs, 0);
  }
  explicit ResourcesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourcesBuilder &operator=(const ResourcesBuilder &);
  flatbuffers::Offset<Resources> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resources>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resources> CreateResources(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ore = 0,
    int32_t gas = 0,
    int32_t used_psi = 0,
    int32_t total_psi = 0,
    int64_t upgrades = 0,
    int64_t upgrades_level = 0,
    int64_t techs = 0) {
  ResourcesBuilder builder_(_fbb);
  builder_.add_techs(techs);
  builder_.add_upgrades_level(upgrades_level);
  builder_.add_upgrades(upgrades);
  builder_.add_total_psi(total_psi);
  builder_.add_used_psi(used_psi);
  builder_.add_gas(gas);
  builder_.add_ore(ore);
  return builder_.Finish();
}

flatbuffers::Offset<Resources> CreateResources(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OrderT : public flatbuffers::NativeTable {
  typedef Order TableType;
  int32_t first_frame;
  int32_t type;
  int32_t targetId;
  int32_t targetX;
  int32_t targetY;
  OrderT()
      : first_frame(0),
        type(0),
        targetId(0),
        targetX(0),
        targetY(0) {
  }
};

struct Order FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OrderT NativeTableType;
  enum {
    VT_FIRST_FRAME = 4,
    VT_TYPE = 6,
    VT_TARGETID = 8,
    VT_TARGETX = 10,
    VT_TARGETY = 12
  };
  int32_t first_frame() const {
    return GetField<int32_t>(VT_FIRST_FRAME, 0);
  }
  bool mutate_first_frame(int32_t _first_frame) {
    return SetField<int32_t>(VT_FIRST_FRAME, _first_frame, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  int32_t targetId() const {
    return GetField<int32_t>(VT_TARGETID, 0);
  }
  bool mutate_targetId(int32_t _targetId) {
    return SetField<int32_t>(VT_TARGETID, _targetId, 0);
  }
  int32_t targetX() const {
    return GetField<int32_t>(VT_TARGETX, 0);
  }
  bool mutate_targetX(int32_t _targetX) {
    return SetField<int32_t>(VT_TARGETX, _targetX, 0);
  }
  int32_t targetY() const {
    return GetField<int32_t>(VT_TARGETY, 0);
  }
  bool mutate_targetY(int32_t _targetY) {
    return SetField<int32_t>(VT_TARGETY, _targetY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FIRST_FRAME) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_TARGETID) &&
           VerifyField<int32_t>(verifier, VT_TARGETX) &&
           VerifyField<int32_t>(verifier, VT_TARGETY) &&
           verifier.EndTable();
  }
  OrderT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OrderT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Order> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OrderT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct OrderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_first_frame(int32_t first_frame) {
    fbb_.AddElement<int32_t>(Order::VT_FIRST_FRAME, first_frame, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Order::VT_TYPE, type, 0);
  }
  void add_targetId(int32_t targetId) {
    fbb_.AddElement<int32_t>(Order::VT_TARGETID, targetId, 0);
  }
  void add_targetX(int32_t targetX) {
    fbb_.AddElement<int32_t>(Order::VT_TARGETX, targetX, 0);
  }
  void add_targetY(int32_t targetY) {
    fbb_.AddElement<int32_t>(Order::VT_TARGETY, targetY, 0);
  }
  explicit OrderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrderBuilder &operator=(const OrderBuilder &);
  flatbuffers::Offset<Order> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Order>(end);
    return o;
  }
};

inline flatbuffers::Offset<Order> CreateOrder(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t first_frame = 0,
    int32_t type = 0,
    int32_t targetId = 0,
    int32_t targetX = 0,
    int32_t targetY = 0) {
  OrderBuilder builder_(_fbb);
  builder_.add_targetY(targetY);
  builder_.add_targetX(targetX);
  builder_.add_targetId(targetId);
  builder_.add_type(type);
  builder_.add_first_frame(first_frame);
  return builder_.Finish();
}

flatbuffers::Offset<Order> CreateOrder(flatbuffers::FlatBufferBuilder &_fbb, const OrderT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnitCommandT : public flatbuffers::NativeTable {
  typedef UnitCommand TableType;
  int32_t frame;
  int32_t type;
  int32_t targetId;
  int32_t targetX;
  int32_t targetY;
  int32_t extra;
  UnitCommandT()
      : frame(0),
        type(0),
        targetId(0),
        targetX(0),
        targetY(0),
        extra(0) {
  }
};

struct UnitCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnitCommandT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_TYPE = 6,
    VT_TARGETID = 8,
    VT_TARGETX = 10,
    VT_TARGETY = 12,
    VT_EXTRA = 14
  };
  int32_t frame() const {
    return GetField<int32_t>(VT_FRAME, 0);
  }
  bool mutate_frame(int32_t _frame) {
    return SetField<int32_t>(VT_FRAME, _frame, 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  int32_t targetId() const {
    return GetField<int32_t>(VT_TARGETID, 0);
  }
  bool mutate_targetId(int32_t _targetId) {
    return SetField<int32_t>(VT_TARGETID, _targetId, 0);
  }
  int32_t targetX() const {
    return GetField<int32_t>(VT_TARGETX, 0);
  }
  bool mutate_targetX(int32_t _targetX) {
    return SetField<int32_t>(VT_TARGETX, _targetX, 0);
  }
  int32_t targetY() const {
    return GetField<int32_t>(VT_TARGETY, 0);
  }
  bool mutate_targetY(int32_t _targetY) {
    return SetField<int32_t>(VT_TARGETY, _targetY, 0);
  }
  int32_t extra() const {
    return GetField<int32_t>(VT_EXTRA, 0);
  }
  bool mutate_extra(int32_t _extra) {
    return SetField<int32_t>(VT_EXTRA, _extra, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FRAME) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_TARGETID) &&
           VerifyField<int32_t>(verifier, VT_TARGETX) &&
           VerifyField<int32_t>(verifier, VT_TARGETY) &&
           VerifyField<int32_t>(verifier, VT_EXTRA) &&
           verifier.EndTable();
  }
  UnitCommandT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnitCommandT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnitCommand> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnitCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(int32_t frame) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_FRAME, frame, 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_TYPE, type, 0);
  }
  void add_targetId(int32_t targetId) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_TARGETID, targetId, 0);
  }
  void add_targetX(int32_t targetX) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_TARGETX, targetX, 0);
  }
  void add_targetY(int32_t targetY) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_TARGETY, targetY, 0);
  }
  void add_extra(int32_t extra) {
    fbb_.AddElement<int32_t>(UnitCommand::VT_EXTRA, extra, 0);
  }
  explicit UnitCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitCommandBuilder &operator=(const UnitCommandBuilder &);
  flatbuffers::Offset<UnitCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnitCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnitCommand> CreateUnitCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t frame = 0,
    int32_t type = 0,
    int32_t targetId = 0,
    int32_t targetX = 0,
    int32_t targetY = 0,
    int32_t extra = 0) {
  UnitCommandBuilder builder_(_fbb);
  builder_.add_extra(extra);
  builder_.add_targetY(targetY);
  builder_.add_targetX(targetX);
  builder_.add_targetId(targetId);
  builder_.add_type(type);
  builder_.add_frame(frame);
  return builder_.Finish();
}

flatbuffers::Offset<UnitCommand> CreateUnitCommand(flatbuffers::FlatBufferBuilder &_fbb, const UnitCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BulletT : public flatbuffers::NativeTable {
  typedef Bullet TableType;
  int32_t type;
  int32_t x;
  int32_t y;
  BulletT()
      : type(0),
        x(0),
        y(0) {
  }
};

struct Bullet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BulletT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_X = 6,
    VT_Y = 8
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  bool mutate_x(int32_t _x) {
    return SetField<int32_t>(VT_X, _x, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  bool mutate_y(int32_t _y) {
    return SetField<int32_t>(VT_Y, _y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
  BulletT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BulletT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Bullet> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BulletT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BulletBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Bullet::VT_TYPE, type, 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(Bullet::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(Bullet::VT_Y, y, 0);
  }
  explicit BulletBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BulletBuilder &operator=(const BulletBuilder &);
  flatbuffers::Offset<Bullet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bullet>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bullet> CreateBullet(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    int32_t x = 0,
    int32_t y = 0) {
  BulletBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<Bullet> CreateBullet(flatbuffers::FlatBufferBuilder &_fbb, const BulletT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnitT : public flatbuffers::NativeTable {
  typedef Unit TableType;
  int32_t id;
  int32_t x;
  int32_t y;
  int32_t health;
  int32_t max_health;
  int32_t shield;
  int32_t max_shield;
  int32_t energy;
  int32_t maxCD;
  int32_t groundCD;
  int32_t airCD;
  int64_t flags;
  bool visible;
  int32_t type;
  int32_t armor;
  int32_t shieldArmor;
  int32_t size;
  int32_t pixel_x;
  int32_t pixel_y;
  int32_t pixel_size_x;
  int32_t pixel_size_y;
  int32_t groundATK;
  int32_t airATK;
  int32_t groundDmgType;
  int32_t airDmgType;
  int32_t groundRange;
  int32_t airRange;
  std::vector<std::unique_ptr<OrderT>> orders;
  std::unique_ptr<UnitCommandT> command;
  double velocityX;
  double velocityY;
  int32_t playerId;
  int32_t resources;
  int32_t buildTechUpgradeType;
  int32_t remainingBuildTrainTime;
  int32_t remainingUpgradeResearchTime;
  int32_t spellCD;
  int32_t associatedUnit;
  int32_t associatedCount;
  UnitT()
      : id(0),
        x(0),
        y(0),
        health(0),
        max_health(0),
        shield(0),
        max_shield(0),
        energy(0),
        maxCD(0),
        groundCD(0),
        airCD(0),
        flags(0),
        visible(false),
        type(0),
        armor(0),
        shieldArmor(0),
        size(0),
        pixel_x(0),
        pixel_y(0),
        pixel_size_x(0),
        pixel_size_y(0),
        groundATK(0),
        airATK(0),
        groundDmgType(0),
        airDmgType(0),
        groundRange(0),
        airRange(0),
        velocityX(0.0),
        velocityY(0.0),
        playerId(0),
        resources(0),
        buildTechUpgradeType(0),
        remainingBuildTrainTime(0),
        remainingUpgradeResearchTime(0),
        spellCD(0),
        associatedUnit(0),
        associatedCount(0) {
  }
};

struct Unit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnitT NativeTableType;
  enum {
    VT_ID = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_HEALTH = 10,
    VT_MAX_HEALTH = 12,
    VT_SHIELD = 14,
    VT_MAX_SHIELD = 16,
    VT_ENERGY = 18,
    VT_MAXCD = 20,
    VT_GROUNDCD = 22,
    VT_AIRCD = 24,
    VT_FLAGS = 26,
    VT_VISIBLE = 28,
    VT_TYPE = 30,
    VT_ARMOR = 32,
    VT_SHIELDARMOR = 34,
    VT_SIZE = 36,
    VT_PIXEL_X = 38,
    VT_PIXEL_Y = 40,
    VT_PIXEL_SIZE_X = 42,
    VT_PIXEL_SIZE_Y = 44,
    VT_GROUNDATK = 46,
    VT_AIRATK = 48,
    VT_GROUNDDMGTYPE = 50,
    VT_AIRDMGTYPE = 52,
    VT_GROUNDRANGE = 54,
    VT_AIRRANGE = 56,
    VT_ORDERS = 58,
    VT_COMMAND = 60,
    VT_VELOCITYX = 62,
    VT_VELOCITYY = 64,
    VT_PLAYERID = 66,
    VT_RESOURCES = 68,
    VT_BUILDTECHUPGRADETYPE = 70,
    VT_REMAININGBUILDTRAINTIME = 72,
    VT_REMAININGUPGRADERESEARCHTIME = 74,
    VT_SPELLCD = 76,
    VT_ASSOCIATEDUNIT = 78,
    VT_ASSOCIATEDCOUNT = 80
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool mutate_id(int32_t _id) {
    return SetField<int32_t>(VT_ID, _id, 0);
  }
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  bool mutate_x(int32_t _x) {
    return SetField<int32_t>(VT_X, _x, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  bool mutate_y(int32_t _y) {
    return SetField<int32_t>(VT_Y, _y, 0);
  }
  int32_t health() const {
    return GetField<int32_t>(VT_HEALTH, 0);
  }
  bool mutate_health(int32_t _health) {
    return SetField<int32_t>(VT_HEALTH, _health, 0);
  }
  int32_t max_health() const {
    return GetField<int32_t>(VT_MAX_HEALTH, 0);
  }
  bool mutate_max_health(int32_t _max_health) {
    return SetField<int32_t>(VT_MAX_HEALTH, _max_health, 0);
  }
  int32_t shield() const {
    return GetField<int32_t>(VT_SHIELD, 0);
  }
  bool mutate_shield(int32_t _shield) {
    return SetField<int32_t>(VT_SHIELD, _shield, 0);
  }
  int32_t max_shield() const {
    return GetField<int32_t>(VT_MAX_SHIELD, 0);
  }
  bool mutate_max_shield(int32_t _max_shield) {
    return SetField<int32_t>(VT_MAX_SHIELD, _max_shield, 0);
  }
  int32_t energy() const {
    return GetField<int32_t>(VT_ENERGY, 0);
  }
  bool mutate_energy(int32_t _energy) {
    return SetField<int32_t>(VT_ENERGY, _energy, 0);
  }
  int32_t maxCD() const {
    return GetField<int32_t>(VT_MAXCD, 0);
  }
  bool mutate_maxCD(int32_t _maxCD) {
    return SetField<int32_t>(VT_MAXCD, _maxCD, 0);
  }
  int32_t groundCD() const {
    return GetField<int32_t>(VT_GROUNDCD, 0);
  }
  bool mutate_groundCD(int32_t _groundCD) {
    return SetField<int32_t>(VT_GROUNDCD, _groundCD, 0);
  }
  int32_t airCD() const {
    return GetField<int32_t>(VT_AIRCD, 0);
  }
  bool mutate_airCD(int32_t _airCD) {
    return SetField<int32_t>(VT_AIRCD, _airCD, 0);
  }
  int64_t flags() const {
    return GetField<int64_t>(VT_FLAGS, 0);
  }
  bool mutate_flags(int64_t _flags) {
    return SetField<int64_t>(VT_FLAGS, _flags, 0);
  }
  bool visible() const {
    return GetField<uint8_t>(VT_VISIBLE, 0) != 0;
  }
  bool mutate_visible(bool _visible) {
    return SetField<uint8_t>(VT_VISIBLE, static_cast<uint8_t>(_visible), 0);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool mutate_type(int32_t _type) {
    return SetField<int32_t>(VT_TYPE, _type, 0);
  }
  int32_t armor() const {
    return GetField<int32_t>(VT_ARMOR, 0);
  }
  bool mutate_armor(int32_t _armor) {
    return SetField<int32_t>(VT_ARMOR, _armor, 0);
  }
  int32_t shieldArmor() const {
    return GetField<int32_t>(VT_SHIELDARMOR, 0);
  }
  bool mutate_shieldArmor(int32_t _shieldArmor) {
    return SetField<int32_t>(VT_SHIELDARMOR, _shieldArmor, 0);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  bool mutate_size(int32_t _size) {
    return SetField<int32_t>(VT_SIZE, _size, 0);
  }
  int32_t pixel_x() const {
    return GetField<int32_t>(VT_PIXEL_X, 0);
  }
  bool mutate_pixel_x(int32_t _pixel_x) {
    return SetField<int32_t>(VT_PIXEL_X, _pixel_x, 0);
  }
  int32_t pixel_y() const {
    return GetField<int32_t>(VT_PIXEL_Y, 0);
  }
  bool mutate_pixel_y(int32_t _pixel_y) {
    return SetField<int32_t>(VT_PIXEL_Y, _pixel_y, 0);
  }
  int32_t pixel_size_x() const {
    return GetField<int32_t>(VT_PIXEL_SIZE_X, 0);
  }
  bool mutate_pixel_size_x(int32_t _pixel_size_x) {
    return SetField<int32_t>(VT_PIXEL_SIZE_X, _pixel_size_x, 0);
  }
  int32_t pixel_size_y() const {
    return GetField<int32_t>(VT_PIXEL_SIZE_Y, 0);
  }
  bool mutate_pixel_size_y(int32_t _pixel_size_y) {
    return SetField<int32_t>(VT_PIXEL_SIZE_Y, _pixel_size_y, 0);
  }
  int32_t groundATK() const {
    return GetField<int32_t>(VT_GROUNDATK, 0);
  }
  bool mutate_groundATK(int32_t _groundATK) {
    return SetField<int32_t>(VT_GROUNDATK, _groundATK, 0);
  }
  int32_t airATK() const {
    return GetField<int32_t>(VT_AIRATK, 0);
  }
  bool mutate_airATK(int32_t _airATK) {
    return SetField<int32_t>(VT_AIRATK, _airATK, 0);
  }
  int32_t groundDmgType() const {
    return GetField<int32_t>(VT_GROUNDDMGTYPE, 0);
  }
  bool mutate_groundDmgType(int32_t _groundDmgType) {
    return SetField<int32_t>(VT_GROUNDDMGTYPE, _groundDmgType, 0);
  }
  int32_t airDmgType() const {
    return GetField<int32_t>(VT_AIRDMGTYPE, 0);
  }
  bool mutate_airDmgType(int32_t _airDmgType) {
    return SetField<int32_t>(VT_AIRDMGTYPE, _airDmgType, 0);
  }
  int32_t groundRange() const {
    return GetField<int32_t>(VT_GROUNDRANGE, 0);
  }
  bool mutate_groundRange(int32_t _groundRange) {
    return SetField<int32_t>(VT_GROUNDRANGE, _groundRange, 0);
  }
  int32_t airRange() const {
    return GetField<int32_t>(VT_AIRRANGE, 0);
  }
  bool mutate_airRange(int32_t _airRange) {
    return SetField<int32_t>(VT_AIRRANGE, _airRange, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Order>> *orders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Order>> *>(VT_ORDERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Order>> *mutable_orders() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Order>> *>(VT_ORDERS);
  }
  const UnitCommand *command() const {
    return GetPointer<const UnitCommand *>(VT_COMMAND);
  }
  UnitCommand *mutable_command() {
    return GetPointer<UnitCommand *>(VT_COMMAND);
  }
  double velocityX() const {
    return GetField<double>(VT_VELOCITYX, 0.0);
  }
  bool mutate_velocityX(double _velocityX) {
    return SetField<double>(VT_VELOCITYX, _velocityX, 0.0);
  }
  double velocityY() const {
    return GetField<double>(VT_VELOCITYY, 0.0);
  }
  bool mutate_velocityY(double _velocityY) {
    return SetField<double>(VT_VELOCITYY, _velocityY, 0.0);
  }
  int32_t playerId() const {
    return GetField<int32_t>(VT_PLAYERID, 0);
  }
  bool mutate_playerId(int32_t _playerId) {
    return SetField<int32_t>(VT_PLAYERID, _playerId, 0);
  }
  int32_t resources() const {
    return GetField<int32_t>(VT_RESOURCES, 0);
  }
  bool mutate_resources(int32_t _resources) {
    return SetField<int32_t>(VT_RESOURCES, _resources, 0);
  }
  int32_t buildTechUpgradeType() const {
    return GetField<int32_t>(VT_BUILDTECHUPGRADETYPE, 0);
  }
  bool mutate_buildTechUpgradeType(int32_t _buildTechUpgradeType) {
    return SetField<int32_t>(VT_BUILDTECHUPGRADETYPE, _buildTechUpgradeType, 0);
  }
  int32_t remainingBuildTrainTime() const {
    return GetField<int32_t>(VT_REMAININGBUILDTRAINTIME, 0);
  }
  bool mutate_remainingBuildTrainTime(int32_t _remainingBuildTrainTime) {
    return SetField<int32_t>(VT_REMAININGBUILDTRAINTIME, _remainingBuildTrainTime, 0);
  }
  int32_t remainingUpgradeResearchTime() const {
    return GetField<int32_t>(VT_REMAININGUPGRADERESEARCHTIME, 0);
  }
  bool mutate_remainingUpgradeResearchTime(int32_t _remainingUpgradeResearchTime) {
    return SetField<int32_t>(VT_REMAININGUPGRADERESEARCHTIME, _remainingUpgradeResearchTime, 0);
  }
  int32_t spellCD() const {
    return GetField<int32_t>(VT_SPELLCD, 0);
  }
  bool mutate_spellCD(int32_t _spellCD) {
    return SetField<int32_t>(VT_SPELLCD, _spellCD, 0);
  }
  int32_t associatedUnit() const {
    return GetField<int32_t>(VT_ASSOCIATEDUNIT, 0);
  }
  bool mutate_associatedUnit(int32_t _associatedUnit) {
    return SetField<int32_t>(VT_ASSOCIATEDUNIT, _associatedUnit, 0);
  }
  int32_t associatedCount() const {
    return GetField<int32_t>(VT_ASSOCIATEDCOUNT, 0);
  }
  bool mutate_associatedCount(int32_t _associatedCount) {
    return SetField<int32_t>(VT_ASSOCIATEDCOUNT, _associatedCount, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_HEALTH) &&
           VerifyField<int32_t>(verifier, VT_MAX_HEALTH) &&
           VerifyField<int32_t>(verifier, VT_SHIELD) &&
           VerifyField<int32_t>(verifier, VT_MAX_SHIELD) &&
           VerifyField<int32_t>(verifier, VT_ENERGY) &&
           VerifyField<int32_t>(verifier, VT_MAXCD) &&
           VerifyField<int32_t>(verifier, VT_GROUNDCD) &&
           VerifyField<int32_t>(verifier, VT_AIRCD) &&
           VerifyField<int64_t>(verifier, VT_FLAGS) &&
           VerifyField<uint8_t>(verifier, VT_VISIBLE) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_ARMOR) &&
           VerifyField<int32_t>(verifier, VT_SHIELDARMOR) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_PIXEL_X) &&
           VerifyField<int32_t>(verifier, VT_PIXEL_Y) &&
           VerifyField<int32_t>(verifier, VT_PIXEL_SIZE_X) &&
           VerifyField<int32_t>(verifier, VT_PIXEL_SIZE_Y) &&
           VerifyField<int32_t>(verifier, VT_GROUNDATK) &&
           VerifyField<int32_t>(verifier, VT_AIRATK) &&
           VerifyField<int32_t>(verifier, VT_GROUNDDMGTYPE) &&
           VerifyField<int32_t>(verifier, VT_AIRDMGTYPE) &&
           VerifyField<int32_t>(verifier, VT_GROUNDRANGE) &&
           VerifyField<int32_t>(verifier, VT_AIRRANGE) &&
           VerifyOffset(verifier, VT_ORDERS) &&
           verifier.Verify(orders()) &&
           verifier.VerifyVectorOfTables(orders()) &&
           VerifyOffset(verifier, VT_COMMAND) &&
           verifier.VerifyTable(command()) &&
           VerifyField<double>(verifier, VT_VELOCITYX) &&
           VerifyField<double>(verifier, VT_VELOCITYY) &&
           VerifyField<int32_t>(verifier, VT_PLAYERID) &&
           VerifyField<int32_t>(verifier, VT_RESOURCES) &&
           VerifyField<int32_t>(verifier, VT_BUILDTECHUPGRADETYPE) &&
           VerifyField<int32_t>(verifier, VT_REMAININGBUILDTRAINTIME) &&
           VerifyField<int32_t>(verifier, VT_REMAININGUPGRADERESEARCHTIME) &&
           VerifyField<int32_t>(verifier, VT_SPELLCD) &&
           VerifyField<int32_t>(verifier, VT_ASSOCIATEDUNIT) &&
           VerifyField<int32_t>(verifier, VT_ASSOCIATEDCOUNT) &&
           verifier.EndTable();
  }
  UnitT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnitT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Unit> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Unit::VT_ID, id, 0);
  }
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(Unit::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(Unit::VT_Y, y, 0);
  }
  void add_health(int32_t health) {
    fbb_.AddElement<int32_t>(Unit::VT_HEALTH, health, 0);
  }
  void add_max_health(int32_t max_health) {
    fbb_.AddElement<int32_t>(Unit::VT_MAX_HEALTH, max_health, 0);
  }
  void add_shield(int32_t shield) {
    fbb_.AddElement<int32_t>(Unit::VT_SHIELD, shield, 0);
  }
  void add_max_shield(int32_t max_shield) {
    fbb_.AddElement<int32_t>(Unit::VT_MAX_SHIELD, max_shield, 0);
  }
  void add_energy(int32_t energy) {
    fbb_.AddElement<int32_t>(Unit::VT_ENERGY, energy, 0);
  }
  void add_maxCD(int32_t maxCD) {
    fbb_.AddElement<int32_t>(Unit::VT_MAXCD, maxCD, 0);
  }
  void add_groundCD(int32_t groundCD) {
    fbb_.AddElement<int32_t>(Unit::VT_GROUNDCD, groundCD, 0);
  }
  void add_airCD(int32_t airCD) {
    fbb_.AddElement<int32_t>(Unit::VT_AIRCD, airCD, 0);
  }
  void add_flags(int64_t flags) {
    fbb_.AddElement<int64_t>(Unit::VT_FLAGS, flags, 0);
  }
  void add_visible(bool visible) {
    fbb_.AddElement<uint8_t>(Unit::VT_VISIBLE, static_cast<uint8_t>(visible), 0);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Unit::VT_TYPE, type, 0);
  }
  void add_armor(int32_t armor) {
    fbb_.AddElement<int32_t>(Unit::VT_ARMOR, armor, 0);
  }
  void add_shieldArmor(int32_t shieldArmor) {
    fbb_.AddElement<int32_t>(Unit::VT_SHIELDARMOR, shieldArmor, 0);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(Unit::VT_SIZE, size, 0);
  }
  void add_pixel_x(int32_t pixel_x) {
    fbb_.AddElement<int32_t>(Unit::VT_PIXEL_X, pixel_x, 0);
  }
  void add_pixel_y(int32_t pixel_y) {
    fbb_.AddElement<int32_t>(Unit::VT_PIXEL_Y, pixel_y, 0);
  }
  void add_pixel_size_x(int32_t pixel_size_x) {
    fbb_.AddElement<int32_t>(Unit::VT_PIXEL_SIZE_X, pixel_size_x, 0);
  }
  void add_pixel_size_y(int32_t pixel_size_y) {
    fbb_.AddElement<int32_t>(Unit::VT_PIXEL_SIZE_Y, pixel_size_y, 0);
  }
  void add_groundATK(int32_t groundATK) {
    fbb_.AddElement<int32_t>(Unit::VT_GROUNDATK, groundATK, 0);
  }
  void add_airATK(int32_t airATK) {
    fbb_.AddElement<int32_t>(Unit::VT_AIRATK, airATK, 0);
  }
  void add_groundDmgType(int32_t groundDmgType) {
    fbb_.AddElement<int32_t>(Unit::VT_GROUNDDMGTYPE, groundDmgType, 0);
  }
  void add_airDmgType(int32_t airDmgType) {
    fbb_.AddElement<int32_t>(Unit::VT_AIRDMGTYPE, airDmgType, 0);
  }
  void add_groundRange(int32_t groundRange) {
    fbb_.AddElement<int32_t>(Unit::VT_GROUNDRANGE, groundRange, 0);
  }
  void add_airRange(int32_t airRange) {
    fbb_.AddElement<int32_t>(Unit::VT_AIRRANGE, airRange, 0);
  }
  void add_orders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Order>>> orders) {
    fbb_.AddOffset(Unit::VT_ORDERS, orders);
  }
  void add_command(flatbuffers::Offset<UnitCommand> command) {
    fbb_.AddOffset(Unit::VT_COMMAND, command);
  }
  void add_velocityX(double velocityX) {
    fbb_.AddElement<double>(Unit::VT_VELOCITYX, velocityX, 0.0);
  }
  void add_velocityY(double velocityY) {
    fbb_.AddElement<double>(Unit::VT_VELOCITYY, velocityY, 0.0);
  }
  void add_playerId(int32_t playerId) {
    fbb_.AddElement<int32_t>(Unit::VT_PLAYERID, playerId, 0);
  }
  void add_resources(int32_t resources) {
    fbb_.AddElement<int32_t>(Unit::VT_RESOURCES, resources, 0);
  }
  void add_buildTechUpgradeType(int32_t buildTechUpgradeType) {
    fbb_.AddElement<int32_t>(Unit::VT_BUILDTECHUPGRADETYPE, buildTechUpgradeType, 0);
  }
  void add_remainingBuildTrainTime(int32_t remainingBuildTrainTime) {
    fbb_.AddElement<int32_t>(Unit::VT_REMAININGBUILDTRAINTIME, remainingBuildTrainTime, 0);
  }
  void add_remainingUpgradeResearchTime(int32_t remainingUpgradeResearchTime) {
    fbb_.AddElement<int32_t>(Unit::VT_REMAININGUPGRADERESEARCHTIME, remainingUpgradeResearchTime, 0);
  }
  void add_spellCD(int32_t spellCD) {
    fbb_.AddElement<int32_t>(Unit::VT_SPELLCD, spellCD, 0);
  }
  void add_associatedUnit(int32_t associatedUnit) {
    fbb_.AddElement<int32_t>(Unit::VT_ASSOCIATEDUNIT, associatedUnit, 0);
  }
  void add_associatedCount(int32_t associatedCount) {
    fbb_.AddElement<int32_t>(Unit::VT_ASSOCIATEDCOUNT, associatedCount, 0);
  }
  explicit UnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitBuilder &operator=(const UnitBuilder &);
  flatbuffers::Offset<Unit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unit>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unit> CreateUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t x = 0,
    int32_t y = 0,
    int32_t health = 0,
    int32_t max_health = 0,
    int32_t shield = 0,
    int32_t max_shield = 0,
    int32_t energy = 0,
    int32_t maxCD = 0,
    int32_t groundCD = 0,
    int32_t airCD = 0,
    int64_t flags = 0,
    bool visible = false,
    int32_t type = 0,
    int32_t armor = 0,
    int32_t shieldArmor = 0,
    int32_t size = 0,
    int32_t pixel_x = 0,
    int32_t pixel_y = 0,
    int32_t pixel_size_x = 0,
    int32_t pixel_size_y = 0,
    int32_t groundATK = 0,
    int32_t airATK = 0,
    int32_t groundDmgType = 0,
    int32_t airDmgType = 0,
    int32_t groundRange = 0,
    int32_t airRange = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Order>>> orders = 0,
    flatbuffers::Offset<UnitCommand> command = 0,
    double velocityX = 0.0,
    double velocityY = 0.0,
    int32_t playerId = 0,
    int32_t resources = 0,
    int32_t buildTechUpgradeType = 0,
    int32_t remainingBuildTrainTime = 0,
    int32_t remainingUpgradeResearchTime = 0,
    int32_t spellCD = 0,
    int32_t associatedUnit = 0,
    int32_t associatedCount = 0) {
  UnitBuilder builder_(_fbb);
  builder_.add_velocityY(velocityY);
  builder_.add_velocityX(velocityX);
  builder_.add_flags(flags);
  builder_.add_associatedCount(associatedCount);
  builder_.add_associatedUnit(associatedUnit);
  builder_.add_spellCD(spellCD);
  builder_.add_remainingUpgradeResearchTime(remainingUpgradeResearchTime);
  builder_.add_remainingBuildTrainTime(remainingBuildTrainTime);
  builder_.add_buildTechUpgradeType(buildTechUpgradeType);
  builder_.add_resources(resources);
  builder_.add_playerId(playerId);
  builder_.add_command(command);
  builder_.add_orders(orders);
  builder_.add_airRange(airRange);
  builder_.add_groundRange(groundRange);
  builder_.add_airDmgType(airDmgType);
  builder_.add_groundDmgType(groundDmgType);
  builder_.add_airATK(airATK);
  builder_.add_groundATK(groundATK);
  builder_.add_pixel_size_y(pixel_size_y);
  builder_.add_pixel_size_x(pixel_size_x);
  builder_.add_pixel_y(pixel_y);
  builder_.add_pixel_x(pixel_x);
  builder_.add_size(size);
  builder_.add_shieldArmor(shieldArmor);
  builder_.add_armor(armor);
  builder_.add_type(type);
  builder_.add_airCD(airCD);
  builder_.add_groundCD(groundCD);
  builder_.add_maxCD(maxCD);
  builder_.add_energy(energy);
  builder_.add_max_shield(max_shield);
  builder_.add_shield(shield);
  builder_.add_max_health(max_health);
  builder_.add_health(health);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_id(id);
  builder_.add_visible(visible);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unit> CreateUnitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t x = 0,
    int32_t y = 0,
    int32_t health = 0,
    int32_t max_health = 0,
    int32_t shield = 0,
    int32_t max_shield = 0,
    int32_t energy = 0,
    int32_t maxCD = 0,
    int32_t groundCD = 0,
    int32_t airCD = 0,
    int64_t flags = 0,
    bool visible = false,
    int32_t type = 0,
    int32_t armor = 0,
    int32_t shieldArmor = 0,
    int32_t size = 0,
    int32_t pixel_x = 0,
    int32_t pixel_y = 0,
    int32_t pixel_size_x = 0,
    int32_t pixel_size_y = 0,
    int32_t groundATK = 0,
    int32_t airATK = 0,
    int32_t groundDmgType = 0,
    int32_t airDmgType = 0,
    int32_t groundRange = 0,
    int32_t airRange = 0,
    const std::vector<flatbuffers::Offset<Order>> *orders = nullptr,
    flatbuffers::Offset<UnitCommand> command = 0,
    double velocityX = 0.0,
    double velocityY = 0.0,
    int32_t playerId = 0,
    int32_t resources = 0,
    int32_t buildTechUpgradeType = 0,
    int32_t remainingBuildTrainTime = 0,
    int32_t remainingUpgradeResearchTime = 0,
    int32_t spellCD = 0,
    int32_t associatedUnit = 0,
    int32_t associatedCount = 0) {
  return torchcraft::fbs::CreateUnit(
      _fbb,
      id,
      x,
      y,
      health,
      max_health,
      shield,
      max_shield,
      energy,
      maxCD,
      groundCD,
      airCD,
      flags,
      visible,
      type,
      armor,
      shieldArmor,
      size,
      pixel_x,
      pixel_y,
      pixel_size_x,
      pixel_size_y,
      groundATK,
      airATK,
      groundDmgType,
      airDmgType,
      groundRange,
      airRange,
      orders ? _fbb.CreateVector<flatbuffers::Offset<Order>>(*orders) : 0,
      command,
      velocityX,
      velocityY,
      playerId,
      resources,
      buildTechUpgradeType,
      remainingBuildTrainTime,
      remainingUpgradeResearchTime,
      spellCD,
      associatedUnit,
      associatedCount);
}

flatbuffers::Offset<Unit> CreateUnit(flatbuffers::FlatBufferBuilder &_fbb, const UnitT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnitsByPlayerIdT : public flatbuffers::NativeTable {
  typedef UnitsByPlayerId TableType;
  int32_t playerId;
  std::vector<std::unique_ptr<UnitT>> units;
  UnitsByPlayerIdT()
      : playerId(0) {
  }
};

struct UnitsByPlayerId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnitsByPlayerIdT NativeTableType;
  enum {
    VT_PLAYERID = 4,
    VT_UNITS = 6
  };
  int32_t playerId() const {
    return GetField<int32_t>(VT_PLAYERID, 0);
  }
  bool mutate_playerId(int32_t _playerId) {
    return SetField<int32_t>(VT_PLAYERID, _playerId, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Unit>> *units() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Unit>> *>(VT_UNITS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Unit>> *mutable_units() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Unit>> *>(VT_UNITS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYERID) &&
           VerifyOffset(verifier, VT_UNITS) &&
           verifier.Verify(units()) &&
           verifier.VerifyVectorOfTables(units()) &&
           verifier.EndTable();
  }
  UnitsByPlayerIdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnitsByPlayerIdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnitsByPlayerId> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitsByPlayerIdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnitsByPlayerIdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playerId(int32_t playerId) {
    fbb_.AddElement<int32_t>(UnitsByPlayerId::VT_PLAYERID, playerId, 0);
  }
  void add_units(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Unit>>> units) {
    fbb_.AddOffset(UnitsByPlayerId::VT_UNITS, units);
  }
  explicit UnitsByPlayerIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitsByPlayerIdBuilder &operator=(const UnitsByPlayerIdBuilder &);
  flatbuffers::Offset<UnitsByPlayerId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnitsByPlayerId>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnitsByPlayerId> CreateUnitsByPlayerId(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Unit>>> units = 0) {
  UnitsByPlayerIdBuilder builder_(_fbb);
  builder_.add_units(units);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<UnitsByPlayerId> CreateUnitsByPlayerIdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerId = 0,
    const std::vector<flatbuffers::Offset<Unit>> *units = nullptr) {
  return torchcraft::fbs::CreateUnitsByPlayerId(
      _fbb,
      playerId,
      units ? _fbb.CreateVector<flatbuffers::Offset<Unit>>(*units) : 0);
}

flatbuffers::Offset<UnitsByPlayerId> CreateUnitsByPlayerId(flatbuffers::FlatBufferBuilder &_fbb, const UnitsByPlayerIdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ActionsByPlayerIdT : public flatbuffers::NativeTable {
  typedef ActionsByPlayerId TableType;
  int32_t playerId;
  std::vector<std::unique_ptr<ActionT>> actions;
  ActionsByPlayerIdT()
      : playerId(0) {
  }
};

struct ActionsByPlayerId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActionsByPlayerIdT NativeTableType;
  enum {
    VT_PLAYERID = 4,
    VT_ACTIONS = 6
  };
  int32_t playerId() const {
    return GetField<int32_t>(VT_PLAYERID, 0);
  }
  bool mutate_playerId(int32_t _playerId) {
    return SetField<int32_t>(VT_PLAYERID, _playerId, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Action>> *actions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Action>> *>(VT_ACTIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Action>> *mutable_actions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Action>> *>(VT_ACTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYERID) &&
           VerifyOffset(verifier, VT_ACTIONS) &&
           verifier.Verify(actions()) &&
           verifier.VerifyVectorOfTables(actions()) &&
           verifier.EndTable();
  }
  ActionsByPlayerIdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ActionsByPlayerIdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ActionsByPlayerId> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionsByPlayerIdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ActionsByPlayerIdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playerId(int32_t playerId) {
    fbb_.AddElement<int32_t>(ActionsByPlayerId::VT_PLAYERID, playerId, 0);
  }
  void add_actions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Action>>> actions) {
    fbb_.AddOffset(ActionsByPlayerId::VT_ACTIONS, actions);
  }
  explicit ActionsByPlayerIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActionsByPlayerIdBuilder &operator=(const ActionsByPlayerIdBuilder &);
  flatbuffers::Offset<ActionsByPlayerId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActionsByPlayerId>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActionsByPlayerId> CreateActionsByPlayerId(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Action>>> actions = 0) {
  ActionsByPlayerIdBuilder builder_(_fbb);
  builder_.add_actions(actions);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ActionsByPlayerId> CreateActionsByPlayerIdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerId = 0,
    const std::vector<flatbuffers::Offset<Action>> *actions = nullptr) {
  return torchcraft::fbs::CreateActionsByPlayerId(
      _fbb,
      playerId,
      actions ? _fbb.CreateVector<flatbuffers::Offset<Action>>(*actions) : 0);
}

flatbuffers::Offset<ActionsByPlayerId> CreateActionsByPlayerId(flatbuffers::FlatBufferBuilder &_fbb, const ActionsByPlayerIdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ResourcesByPlayerIdT : public flatbuffers::NativeTable {
  typedef ResourcesByPlayerId TableType;
  int32_t playerId;
  std::unique_ptr<ResourcesT> resources;
  ResourcesByPlayerIdT()
      : playerId(0) {
  }
};

struct ResourcesByPlayerId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResourcesByPlayerIdT NativeTableType;
  enum {
    VT_PLAYERID = 4,
    VT_RESOURCES = 6
  };
  int32_t playerId() const {
    return GetField<int32_t>(VT_PLAYERID, 0);
  }
  bool mutate_playerId(int32_t _playerId) {
    return SetField<int32_t>(VT_PLAYERID, _playerId, 0);
  }
  const Resources *resources() const {
    return GetPointer<const Resources *>(VT_RESOURCES);
  }
  Resources *mutable_resources() {
    return GetPointer<Resources *>(VT_RESOURCES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PLAYERID) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyTable(resources()) &&
           verifier.EndTable();
  }
  ResourcesByPlayerIdT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ResourcesByPlayerIdT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ResourcesByPlayerId> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesByPlayerIdT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ResourcesByPlayerIdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_playerId(int32_t playerId) {
    fbb_.AddElement<int32_t>(ResourcesByPlayerId::VT_PLAYERID, playerId, 0);
  }
  void add_resources(flatbuffers::Offset<Resources> resources) {
    fbb_.AddOffset(ResourcesByPlayerId::VT_RESOURCES, resources);
  }
  explicit ResourcesByPlayerIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourcesByPlayerIdBuilder &operator=(const ResourcesByPlayerIdBuilder &);
  flatbuffers::Offset<ResourcesByPlayerId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResourcesByPlayerId>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResourcesByPlayerId> CreateResourcesByPlayerId(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t playerId = 0,
    flatbuffers::Offset<Resources> resources = 0) {
  ResourcesByPlayerIdBuilder builder_(_fbb);
  builder_.add_resources(resources);
  builder_.add_playerId(playerId);
  return builder_.Finish();
}

flatbuffers::Offset<ResourcesByPlayerId> CreateResourcesByPlayerId(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesByPlayerIdT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameT : public flatbuffers::NativeTable {
  typedef Frame TableType;
  std::vector<std::unique_ptr<UnitsByPlayerIdT>> units;
  std::vector<std::unique_ptr<ActionsByPlayerIdT>> actions;
  std::vector<std::unique_ptr<ResourcesByPlayerIdT>> resources;
  std::vector<std::unique_ptr<BulletT>> bullets;
  std::vector<uint8_t> creep_map;
  uint32_t width;
  uint32_t height;
  int32_t reward;
  bool is_terminal;
  FrameT()
      : width(0),
        height(0),
        reward(0),
        is_terminal(false) {
  }
};

struct Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameT NativeTableType;
  enum {
    VT_UNITS = 4,
    VT_ACTIONS = 6,
    VT_RESOURCES = 8,
    VT_BULLETS = 10,
    VT_CREEP_MAP = 12,
    VT_WIDTH = 14,
    VT_HEIGHT = 16,
    VT_REWARD = 18,
    VT_IS_TERMINAL = 20
  };
  const flatbuffers::Vector<flatbuffers::Offset<UnitsByPlayerId>> *units() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UnitsByPlayerId>> *>(VT_UNITS);
  }
  flatbuffers::Vector<flatbuffers::Offset<UnitsByPlayerId>> *mutable_units() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UnitsByPlayerId>> *>(VT_UNITS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>> *actions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>> *>(VT_ACTIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>> *mutable_actions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>> *>(VT_ACTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>> *resources() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>> *>(VT_RESOURCES);
  }
  flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>> *mutable_resources() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>> *>(VT_RESOURCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Bullet>> *bullets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Bullet>> *>(VT_BULLETS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Bullet>> *mutable_bullets() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Bullet>> *>(VT_BULLETS);
  }
  const flatbuffers::Vector<uint8_t> *creep_map() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CREEP_MAP);
  }
  flatbuffers::Vector<uint8_t> *mutable_creep_map() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_CREEP_MAP);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  bool mutate_width(uint32_t _width) {
    return SetField<uint32_t>(VT_WIDTH, _width, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  bool mutate_height(uint32_t _height) {
    return SetField<uint32_t>(VT_HEIGHT, _height, 0);
  }
  int32_t reward() const {
    return GetField<int32_t>(VT_REWARD, 0);
  }
  bool mutate_reward(int32_t _reward) {
    return SetField<int32_t>(VT_REWARD, _reward, 0);
  }
  bool is_terminal() const {
    return GetField<uint8_t>(VT_IS_TERMINAL, 0) != 0;
  }
  bool mutate_is_terminal(bool _is_terminal) {
    return SetField<uint8_t>(VT_IS_TERMINAL, static_cast<uint8_t>(_is_terminal), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNITS) &&
           verifier.Verify(units()) &&
           verifier.VerifyVectorOfTables(units()) &&
           VerifyOffset(verifier, VT_ACTIONS) &&
           verifier.Verify(actions()) &&
           verifier.VerifyVectorOfTables(actions()) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.Verify(resources()) &&
           verifier.VerifyVectorOfTables(resources()) &&
           VerifyOffset(verifier, VT_BULLETS) &&
           verifier.Verify(bullets()) &&
           verifier.VerifyVectorOfTables(bullets()) &&
           VerifyOffset(verifier, VT_CREEP_MAP) &&
           verifier.Verify(creep_map()) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<int32_t>(verifier, VT_REWARD) &&
           VerifyField<uint8_t>(verifier, VT_IS_TERMINAL) &&
           verifier.EndTable();
  }
  FrameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Frame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_units(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UnitsByPlayerId>>> units) {
    fbb_.AddOffset(Frame::VT_UNITS, units);
  }
  void add_actions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>>> actions) {
    fbb_.AddOffset(Frame::VT_ACTIONS, actions);
  }
  void add_resources(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>>> resources) {
    fbb_.AddOffset(Frame::VT_RESOURCES, resources);
  }
  void add_bullets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bullet>>> bullets) {
    fbb_.AddOffset(Frame::VT_BULLETS, bullets);
  }
  void add_creep_map(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> creep_map) {
    fbb_.AddOffset(Frame::VT_CREEP_MAP, creep_map);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(Frame::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(Frame::VT_HEIGHT, height, 0);
  }
  void add_reward(int32_t reward) {
    fbb_.AddElement<int32_t>(Frame::VT_REWARD, reward, 0);
  }
  void add_is_terminal(bool is_terminal) {
    fbb_.AddElement<uint8_t>(Frame::VT_IS_TERMINAL, static_cast<uint8_t>(is_terminal), 0);
  }
  explicit FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameBuilder &operator=(const FrameBuilder &);
  flatbuffers::Offset<Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Frame>(end);
    return o;
  }
};

inline flatbuffers::Offset<Frame> CreateFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UnitsByPlayerId>>> units = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>>> actions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>>> resources = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bullet>>> bullets = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> creep_map = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    int32_t reward = 0,
    bool is_terminal = false) {
  FrameBuilder builder_(_fbb);
  builder_.add_reward(reward);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_creep_map(creep_map);
  builder_.add_bullets(bullets);
  builder_.add_resources(resources);
  builder_.add_actions(actions);
  builder_.add_units(units);
  builder_.add_is_terminal(is_terminal);
  return builder_.Finish();
}

inline flatbuffers::Offset<Frame> CreateFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<UnitsByPlayerId>> *units = nullptr,
    const std::vector<flatbuffers::Offset<ActionsByPlayerId>> *actions = nullptr,
    const std::vector<flatbuffers::Offset<ResourcesByPlayerId>> *resources = nullptr,
    const std::vector<flatbuffers::Offset<Bullet>> *bullets = nullptr,
    const std::vector<uint8_t> *creep_map = nullptr,
    uint32_t width = 0,
    uint32_t height = 0,
    int32_t reward = 0,
    bool is_terminal = false) {
  return torchcraft::fbs::CreateFrame(
      _fbb,
      units ? _fbb.CreateVector<flatbuffers::Offset<UnitsByPlayerId>>(*units) : 0,
      actions ? _fbb.CreateVector<flatbuffers::Offset<ActionsByPlayerId>>(*actions) : 0,
      resources ? _fbb.CreateVector<flatbuffers::Offset<ResourcesByPlayerId>>(*resources) : 0,
      bullets ? _fbb.CreateVector<flatbuffers::Offset<Bullet>>(*bullets) : 0,
      creep_map ? _fbb.CreateVector<uint8_t>(*creep_map) : 0,
      width,
      height,
      reward,
      is_terminal);
}

flatbuffers::Offset<Frame> CreateFrame(flatbuffers::FlatBufferBuilder &_fbb, const FrameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnitDiffT : public flatbuffers::NativeTable {
  typedef UnitDiff TableType;
  int32_t id;
  std::vector<int32_t> var_ids;
  std::vector<int32_t> var_diffs;
  std::vector<int32_t> order_ids;
  std::vector<int32_t> order_diffs;
  int32_t order_size;
  double velocityX;
  double velocityY;
  int64_t flags;
  UnitDiffT()
      : id(0),
        order_size(0),
        velocityX(0.0),
        velocityY(0.0),
        flags(0) {
  }
};

struct UnitDiff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnitDiffT NativeTableType;
  enum {
    VT_ID = 4,
    VT_VAR_IDS = 6,
    VT_VAR_DIFFS = 8,
    VT_ORDER_IDS = 10,
    VT_ORDER_DIFFS = 12,
    VT_ORDER_SIZE = 14,
    VT_VELOCITYX = 16,
    VT_VELOCITYY = 18,
    VT_FLAGS = 20
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  bool mutate_id(int32_t _id) {
    return SetField<int32_t>(VT_ID, _id, 0);
  }
  const flatbuffers::Vector<int32_t> *var_ids() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VAR_IDS);
  }
  flatbuffers::Vector<int32_t> *mutable_var_ids() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_VAR_IDS);
  }
  const flatbuffers::Vector<int32_t> *var_diffs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_VAR_DIFFS);
  }
  flatbuffers::Vector<int32_t> *mutable_var_diffs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_VAR_DIFFS);
  }
  const flatbuffers::Vector<int32_t> *order_ids() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ORDER_IDS);
  }
  flatbuffers::Vector<int32_t> *mutable_order_ids() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ORDER_IDS);
  }
  const flatbuffers::Vector<int32_t> *order_diffs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ORDER_DIFFS);
  }
  flatbuffers::Vector<int32_t> *mutable_order_diffs() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_ORDER_DIFFS);
  }
  int32_t order_size() const {
    return GetField<int32_t>(VT_ORDER_SIZE, 0);
  }
  bool mutate_order_size(int32_t _order_size) {
    return SetField<int32_t>(VT_ORDER_SIZE, _order_size, 0);
  }
  double velocityX() const {
    return GetField<double>(VT_VELOCITYX, 0.0);
  }
  bool mutate_velocityX(double _velocityX) {
    return SetField<double>(VT_VELOCITYX, _velocityX, 0.0);
  }
  double velocityY() const {
    return GetField<double>(VT_VELOCITYY, 0.0);
  }
  bool mutate_velocityY(double _velocityY) {
    return SetField<double>(VT_VELOCITYY, _velocityY, 0.0);
  }
  int64_t flags() const {
    return GetField<int64_t>(VT_FLAGS, 0);
  }
  bool mutate_flags(int64_t _flags) {
    return SetField<int64_t>(VT_FLAGS, _flags, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_VAR_IDS) &&
           verifier.Verify(var_ids()) &&
           VerifyOffset(verifier, VT_VAR_DIFFS) &&
           verifier.Verify(var_diffs()) &&
           VerifyOffset(verifier, VT_ORDER_IDS) &&
           verifier.Verify(order_ids()) &&
           VerifyOffset(verifier, VT_ORDER_DIFFS) &&
           verifier.Verify(order_diffs()) &&
           VerifyField<int32_t>(verifier, VT_ORDER_SIZE) &&
           VerifyField<double>(verifier, VT_VELOCITYX) &&
           VerifyField<double>(verifier, VT_VELOCITYY) &&
           VerifyField<int64_t>(verifier, VT_FLAGS) &&
           verifier.EndTable();
  }
  UnitDiffT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnitDiffT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnitDiff> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitDiffT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnitDiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(UnitDiff::VT_ID, id, 0);
  }
  void add_var_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> var_ids) {
    fbb_.AddOffset(UnitDiff::VT_VAR_IDS, var_ids);
  }
  void add_var_diffs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> var_diffs) {
    fbb_.AddOffset(UnitDiff::VT_VAR_DIFFS, var_diffs);
  }
  void add_order_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> order_ids) {
    fbb_.AddOffset(UnitDiff::VT_ORDER_IDS, order_ids);
  }
  void add_order_diffs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> order_diffs) {
    fbb_.AddOffset(UnitDiff::VT_ORDER_DIFFS, order_diffs);
  }
  void add_order_size(int32_t order_size) {
    fbb_.AddElement<int32_t>(UnitDiff::VT_ORDER_SIZE, order_size, 0);
  }
  void add_velocityX(double velocityX) {
    fbb_.AddElement<double>(UnitDiff::VT_VELOCITYX, velocityX, 0.0);
  }
  void add_velocityY(double velocityY) {
    fbb_.AddElement<double>(UnitDiff::VT_VELOCITYY, velocityY, 0.0);
  }
  void add_flags(int64_t flags) {
    fbb_.AddElement<int64_t>(UnitDiff::VT_FLAGS, flags, 0);
  }
  explicit UnitDiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitDiffBuilder &operator=(const UnitDiffBuilder &);
  flatbuffers::Offset<UnitDiff> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnitDiff>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnitDiff> CreateUnitDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> var_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> var_diffs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> order_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> order_diffs = 0,
    int32_t order_size = 0,
    double velocityX = 0.0,
    double velocityY = 0.0,
    int64_t flags = 0) {
  UnitDiffBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_velocityY(velocityY);
  builder_.add_velocityX(velocityX);
  builder_.add_order_size(order_size);
  builder_.add_order_diffs(order_diffs);
  builder_.add_order_ids(order_ids);
  builder_.add_var_diffs(var_diffs);
  builder_.add_var_ids(var_ids);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<UnitDiff> CreateUnitDiffDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const std::vector<int32_t> *var_ids = nullptr,
    const std::vector<int32_t> *var_diffs = nullptr,
    const std::vector<int32_t> *order_ids = nullptr,
    const std::vector<int32_t> *order_diffs = nullptr,
    int32_t order_size = 0,
    double velocityX = 0.0,
    double velocityY = 0.0,
    int64_t flags = 0) {
  return torchcraft::fbs::CreateUnitDiff(
      _fbb,
      id,
      var_ids ? _fbb.CreateVector<int32_t>(*var_ids) : 0,
      var_diffs ? _fbb.CreateVector<int32_t>(*var_diffs) : 0,
      order_ids ? _fbb.CreateVector<int32_t>(*order_ids) : 0,
      order_diffs ? _fbb.CreateVector<int32_t>(*order_diffs) : 0,
      order_size,
      velocityX,
      velocityY,
      flags);
}

flatbuffers::Offset<UnitDiff> CreateUnitDiff(flatbuffers::FlatBufferBuilder &_fbb, const UnitDiffT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnitDiffContainerT : public flatbuffers::NativeTable {
  typedef UnitDiffContainer TableType;
  std::vector<std::unique_ptr<UnitDiffT>> units;
  UnitDiffContainerT() {
  }
};

struct UnitDiffContainer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnitDiffContainerT NativeTableType;
  enum {
    VT_UNITS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<UnitDiff>> *units() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UnitDiff>> *>(VT_UNITS);
  }
  flatbuffers::Vector<flatbuffers::Offset<UnitDiff>> *mutable_units() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UnitDiff>> *>(VT_UNITS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNITS) &&
           verifier.Verify(units()) &&
           verifier.VerifyVectorOfTables(units()) &&
           verifier.EndTable();
  }
  UnitDiffContainerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnitDiffContainerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnitDiffContainer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitDiffContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnitDiffContainerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_units(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UnitDiff>>> units) {
    fbb_.AddOffset(UnitDiffContainer::VT_UNITS, units);
  }
  explicit UnitDiffContainerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitDiffContainerBuilder &operator=(const UnitDiffContainerBuilder &);
  flatbuffers::Offset<UnitDiffContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnitDiffContainer>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnitDiffContainer> CreateUnitDiffContainer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UnitDiff>>> units = 0) {
  UnitDiffContainerBuilder builder_(_fbb);
  builder_.add_units(units);
  return builder_.Finish();
}

inline flatbuffers::Offset<UnitDiffContainer> CreateUnitDiffContainerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<UnitDiff>> *units = nullptr) {
  return torchcraft::fbs::CreateUnitDiffContainer(
      _fbb,
      units ? _fbb.CreateVector<flatbuffers::Offset<UnitDiff>>(*units) : 0);
}

flatbuffers::Offset<UnitDiffContainer> CreateUnitDiffContainer(flatbuffers::FlatBufferBuilder &_fbb, const UnitDiffContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameDiffCreepT : public flatbuffers::NativeTable {
  typedef FrameDiffCreep TableType;
  int32_t index;
  int32_t creep;
  FrameDiffCreepT()
      : index(0),
        creep(0) {
  }
};

struct FrameDiffCreep FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameDiffCreepT NativeTableType;
  enum {
    VT_INDEX = 4,
    VT_CREEP = 6
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool mutate_index(int32_t _index) {
    return SetField<int32_t>(VT_INDEX, _index, 0);
  }
  int32_t creep() const {
    return GetField<int32_t>(VT_CREEP, 0);
  }
  bool mutate_creep(int32_t _creep) {
    return SetField<int32_t>(VT_CREEP, _creep, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_CREEP) &&
           verifier.EndTable();
  }
  FrameDiffCreepT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameDiffCreepT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FrameDiffCreep> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameDiffCreepT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameDiffCreepBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(FrameDiffCreep::VT_INDEX, index, 0);
  }
  void add_creep(int32_t creep) {
    fbb_.AddElement<int32_t>(FrameDiffCreep::VT_CREEP, creep, 0);
  }
  explicit FrameDiffCreepBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameDiffCreepBuilder &operator=(const FrameDiffCreepBuilder &);
  flatbuffers::Offset<FrameDiffCreep> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FrameDiffCreep>(end);
    return o;
  }
};

inline flatbuffers::Offset<FrameDiffCreep> CreateFrameDiffCreep(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0,
    int32_t creep = 0) {
  FrameDiffCreepBuilder builder_(_fbb);
  builder_.add_creep(creep);
  builder_.add_index(index);
  return builder_.Finish();
}

flatbuffers::Offset<FrameDiffCreep> CreateFrameDiffCreep(flatbuffers::FlatBufferBuilder &_fbb, const FrameDiffCreepT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameDiffT : public flatbuffers::NativeTable {
  typedef FrameDiff TableType;
  std::vector<int32_t> pids;
  std::vector<std::unique_ptr<UnitDiffContainerT>> unitDiffContainers;
  std::vector<std::unique_ptr<ActionsByPlayerIdT>> actions;
  std::vector<std::unique_ptr<ResourcesByPlayerIdT>> resources;
  std::vector<std::unique_ptr<BulletT>> bullets;
  std::vector<std::unique_ptr<FrameDiffCreepT>> creep_map;
  int32_t reward;
  int32_t is_terminal;
  FrameDiffT()
      : reward(0),
        is_terminal(0) {
  }
};

struct FrameDiff FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameDiffT NativeTableType;
  enum {
    VT_PIDS = 4,
    VT_UNITDIFFCONTAINERS = 6,
    VT_ACTIONS = 8,
    VT_RESOURCES = 10,
    VT_BULLETS = 12,
    VT_CREEP_MAP = 14,
    VT_REWARD = 16,
    VT_IS_TERMINAL = 18
  };
  const flatbuffers::Vector<int32_t> *pids() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PIDS);
  }
  flatbuffers::Vector<int32_t> *mutable_pids() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_PIDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UnitDiffContainer>> *unitDiffContainers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UnitDiffContainer>> *>(VT_UNITDIFFCONTAINERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<UnitDiffContainer>> *mutable_unitDiffContainers() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UnitDiffContainer>> *>(VT_UNITDIFFCONTAINERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>> *actions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>> *>(VT_ACTIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>> *mutable_actions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>> *>(VT_ACTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>> *resources() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>> *>(VT_RESOURCES);
  }
  flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>> *mutable_resources() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>> *>(VT_RESOURCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Bullet>> *bullets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Bullet>> *>(VT_BULLETS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Bullet>> *mutable_bullets() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Bullet>> *>(VT_BULLETS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FrameDiffCreep>> *creep_map() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FrameDiffCreep>> *>(VT_CREEP_MAP);
  }
  flatbuffers::Vector<flatbuffers::Offset<FrameDiffCreep>> *mutable_creep_map() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<FrameDiffCreep>> *>(VT_CREEP_MAP);
  }
  int32_t reward() const {
    return GetField<int32_t>(VT_REWARD, 0);
  }
  bool mutate_reward(int32_t _reward) {
    return SetField<int32_t>(VT_REWARD, _reward, 0);
  }
  int32_t is_terminal() const {
    return GetField<int32_t>(VT_IS_TERMINAL, 0);
  }
  bool mutate_is_terminal(int32_t _is_terminal) {
    return SetField<int32_t>(VT_IS_TERMINAL, _is_terminal, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PIDS) &&
           verifier.Verify(pids()) &&
           VerifyOffset(verifier, VT_UNITDIFFCONTAINERS) &&
           verifier.Verify(unitDiffContainers()) &&
           verifier.VerifyVectorOfTables(unitDiffContainers()) &&
           VerifyOffset(verifier, VT_ACTIONS) &&
           verifier.Verify(actions()) &&
           verifier.VerifyVectorOfTables(actions()) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.Verify(resources()) &&
           verifier.VerifyVectorOfTables(resources()) &&
           VerifyOffset(verifier, VT_BULLETS) &&
           verifier.Verify(bullets()) &&
           verifier.VerifyVectorOfTables(bullets()) &&
           VerifyOffset(verifier, VT_CREEP_MAP) &&
           verifier.Verify(creep_map()) &&
           verifier.VerifyVectorOfTables(creep_map()) &&
           VerifyField<int32_t>(verifier, VT_REWARD) &&
           VerifyField<int32_t>(verifier, VT_IS_TERMINAL) &&
           verifier.EndTable();
  }
  FrameDiffT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameDiffT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FrameDiff> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameDiffT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameDiffBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pids) {
    fbb_.AddOffset(FrameDiff::VT_PIDS, pids);
  }
  void add_unitDiffContainers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UnitDiffContainer>>> unitDiffContainers) {
    fbb_.AddOffset(FrameDiff::VT_UNITDIFFCONTAINERS, unitDiffContainers);
  }
  void add_actions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>>> actions) {
    fbb_.AddOffset(FrameDiff::VT_ACTIONS, actions);
  }
  void add_resources(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>>> resources) {
    fbb_.AddOffset(FrameDiff::VT_RESOURCES, resources);
  }
  void add_bullets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bullet>>> bullets) {
    fbb_.AddOffset(FrameDiff::VT_BULLETS, bullets);
  }
  void add_creep_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FrameDiffCreep>>> creep_map) {
    fbb_.AddOffset(FrameDiff::VT_CREEP_MAP, creep_map);
  }
  void add_reward(int32_t reward) {
    fbb_.AddElement<int32_t>(FrameDiff::VT_REWARD, reward, 0);
  }
  void add_is_terminal(int32_t is_terminal) {
    fbb_.AddElement<int32_t>(FrameDiff::VT_IS_TERMINAL, is_terminal, 0);
  }
  explicit FrameDiffBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameDiffBuilder &operator=(const FrameDiffBuilder &);
  flatbuffers::Offset<FrameDiff> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FrameDiff>(end);
    return o;
  }
};

inline flatbuffers::Offset<FrameDiff> CreateFrameDiff(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UnitDiffContainer>>> unitDiffContainers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ActionsByPlayerId>>> actions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ResourcesByPlayerId>>> resources = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bullet>>> bullets = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FrameDiffCreep>>> creep_map = 0,
    int32_t reward = 0,
    int32_t is_terminal = 0) {
  FrameDiffBuilder builder_(_fbb);
  builder_.add_is_terminal(is_terminal);
  builder_.add_reward(reward);
  builder_.add_creep_map(creep_map);
  builder_.add_bullets(bullets);
  builder_.add_resources(resources);
  builder_.add_actions(actions);
  builder_.add_unitDiffContainers(unitDiffContainers);
  builder_.add_pids(pids);
  return builder_.Finish();
}

inline flatbuffers::Offset<FrameDiff> CreateFrameDiffDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *pids = nullptr,
    const std::vector<flatbuffers::Offset<UnitDiffContainer>> *unitDiffContainers = nullptr,
    const std::vector<flatbuffers::Offset<ActionsByPlayerId>> *actions = nullptr,
    const std::vector<flatbuffers::Offset<ResourcesByPlayerId>> *resources = nullptr,
    const std::vector<flatbuffers::Offset<Bullet>> *bullets = nullptr,
    const std::vector<flatbuffers::Offset<FrameDiffCreep>> *creep_map = nullptr,
    int32_t reward = 0,
    int32_t is_terminal = 0) {
  return torchcraft::fbs::CreateFrameDiff(
      _fbb,
      pids ? _fbb.CreateVector<int32_t>(*pids) : 0,
      unitDiffContainers ? _fbb.CreateVector<flatbuffers::Offset<UnitDiffContainer>>(*unitDiffContainers) : 0,
      actions ? _fbb.CreateVector<flatbuffers::Offset<ActionsByPlayerId>>(*actions) : 0,
      resources ? _fbb.CreateVector<flatbuffers::Offset<ResourcesByPlayerId>>(*resources) : 0,
      bullets ? _fbb.CreateVector<flatbuffers::Offset<Bullet>>(*bullets) : 0,
      creep_map ? _fbb.CreateVector<flatbuffers::Offset<FrameDiffCreep>>(*creep_map) : 0,
      reward,
      is_terminal);
}

flatbuffers::Offset<FrameDiff> CreateFrameDiff(flatbuffers::FlatBufferBuilder &_fbb, const FrameDiffT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UnitCountT : public flatbuffers::NativeTable {
  typedef UnitCount TableType;
  int32_t a;
  int32_t b;
  UnitCountT()
      : a(0),
        b(0) {
  }
};

struct UnitCount FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnitCountT NativeTableType;
  enum {
    VT_A = 4,
    VT_B = 6
  };
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  bool mutate_a(int32_t _a) {
    return SetField<int32_t>(VT_A, _a, 0);
  }
  int32_t b() const {
    return GetField<int32_t>(VT_B, 0);
  }
  bool mutate_b(int32_t _b) {
    return SetField<int32_t>(VT_B, _b, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_A) &&
           VerifyField<int32_t>(verifier, VT_B) &&
           verifier.EndTable();
  }
  UnitCountT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UnitCountT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UnitCount> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitCountT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UnitCountBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(UnitCount::VT_A, a, 0);
  }
  void add_b(int32_t b) {
    fbb_.AddElement<int32_t>(UnitCount::VT_B, b, 0);
  }
  explicit UnitCountBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnitCountBuilder &operator=(const UnitCountBuilder &);
  flatbuffers::Offset<UnitCount> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnitCount>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnitCount> CreateUnitCount(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t a = 0,
    int32_t b = 0) {
  UnitCountBuilder builder_(_fbb);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

flatbuffers::Offset<UnitCount> CreateUnitCount(flatbuffers::FlatBufferBuilder &_fbb, const UnitCountT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReplayerT : public flatbuffers::NativeTable {
  typedef Replayer TableType;
  std::vector<std::unique_ptr<FrameT>> frames;
  std::vector<std::unique_ptr<UnitCountT>> numUnits;
  std::unique_ptr<MapT> map;
  int32_t keyFrame;
  ReplayerT()
      : keyFrame(0) {
  }
};

struct Replayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReplayerT NativeTableType;
  enum {
    VT_FRAMES = 4,
    VT_NUMUNITS = 6,
    VT_MAP = 8,
    VT_KEYFRAME = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<Frame>> *frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Frame>> *>(VT_FRAMES);
  }
  flatbuffers::Vector<flatbuffers::Offset<Frame>> *mutable_frames() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Frame>> *>(VT_FRAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UnitCount>> *numUnits() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UnitCount>> *>(VT_NUMUNITS);
  }
  flatbuffers::Vector<flatbuffers::Offset<UnitCount>> *mutable_numUnits() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<UnitCount>> *>(VT_NUMUNITS);
  }
  const Map *map() const {
    return GetPointer<const Map *>(VT_MAP);
  }
  Map *mutable_map() {
    return GetPointer<Map *>(VT_MAP);
  }
  int32_t keyFrame() const {
    return GetField<int32_t>(VT_KEYFRAME, 0);
  }
  bool mutate_keyFrame(int32_t _keyFrame) {
    return SetField<int32_t>(VT_KEYFRAME, _keyFrame, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FRAMES) &&
           verifier.Verify(frames()) &&
           verifier.VerifyVectorOfTables(frames()) &&
           VerifyOffset(verifier, VT_NUMUNITS) &&
           verifier.Verify(numUnits()) &&
           verifier.VerifyVectorOfTables(numUnits()) &&
           VerifyOffset(verifier, VT_MAP) &&
           verifier.VerifyTable(map()) &&
           VerifyField<int32_t>(verifier, VT_KEYFRAME) &&
           verifier.EndTable();
  }
  ReplayerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReplayerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Replayer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReplayerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReplayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> frames) {
    fbb_.AddOffset(Replayer::VT_FRAMES, frames);
  }
  void add_numUnits(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UnitCount>>> numUnits) {
    fbb_.AddOffset(Replayer::VT_NUMUNITS, numUnits);
  }
  void add_map(flatbuffers::Offset<Map> map) {
    fbb_.AddOffset(Replayer::VT_MAP, map);
  }
  void add_keyFrame(int32_t keyFrame) {
    fbb_.AddElement<int32_t>(Replayer::VT_KEYFRAME, keyFrame, 0);
  }
  explicit ReplayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReplayerBuilder &operator=(const ReplayerBuilder &);
  flatbuffers::Offset<Replayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Replayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Replayer> CreateReplayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Frame>>> frames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UnitCount>>> numUnits = 0,
    flatbuffers::Offset<Map> map = 0,
    int32_t keyFrame = 0) {
  ReplayerBuilder builder_(_fbb);
  builder_.add_keyFrame(keyFrame);
  builder_.add_map(map);
  builder_.add_numUnits(numUnits);
  builder_.add_frames(frames);
  return builder_.Finish();
}

inline flatbuffers::Offset<Replayer> CreateReplayerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Frame>> *frames = nullptr,
    const std::vector<flatbuffers::Offset<UnitCount>> *numUnits = nullptr,
    flatbuffers::Offset<Map> map = 0,
    int32_t keyFrame = 0) {
  return torchcraft::fbs::CreateReplayer(
      _fbb,
      frames ? _fbb.CreateVector<flatbuffers::Offset<Frame>>(*frames) : 0,
      numUnits ? _fbb.CreateVector<flatbuffers::Offset<UnitCount>>(*numUnits) : 0,
      map,
      keyFrame);
}

flatbuffers::Offset<Replayer> CreateReplayer(flatbuffers::FlatBufferBuilder &_fbb, const ReplayerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CommandT *Command::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CommandT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Command::UnPackTo(CommandT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); _o->code = _e; };
  { auto _e = args(); if (_e) { _o->args.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->args[_i] = _e->Get(_i); } } };
  { auto _e = str(); if (_e) _o->str = _e->str(); };
}

inline flatbuffers::Offset<Command> Command::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommand(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Command> CreateCommand(flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CommandT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code;
  auto _args = _o->args.size() ? _fbb.CreateVector(_o->args) : 0;
  auto _str = _o->str.empty() ? 0 : _fbb.CreateString(_o->str);
  return torchcraft::fbs::CreateCommand(
      _fbb,
      _code,
      _args,
      _str);
}

inline PlayerT *Player::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PlayerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Player::UnPackTo(PlayerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = race(); _o->race = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = is_enemy(); _o->is_enemy = _e; };
}

inline flatbuffers::Offset<Player> Player::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Player> CreatePlayer(flatbuffers::FlatBufferBuilder &_fbb, const PlayerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlayerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _race = _o->race;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _is_enemy = _o->is_enemy;
  return torchcraft::fbs::CreatePlayer(
      _fbb,
      _id,
      _race,
      _name,
      _is_enemy);
}

inline HandshakeClientT *HandshakeClient::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HandshakeClientT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HandshakeClient::UnPackTo(HandshakeClientT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = protocol(); _o->protocol = _e; };
  { auto _e = map(); if (_e) _o->map = _e->str(); };
  { auto _e = window_size(); if (_e) _o->window_size = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = window_pos(); if (_e) _o->window_pos = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = micro_mode(); _o->micro_mode = _e; };
}

inline flatbuffers::Offset<HandshakeClient> HandshakeClient::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeClientT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHandshakeClient(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HandshakeClient> CreateHandshakeClient(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeClientT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HandshakeClientT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _protocol = _o->protocol;
  auto _map = _o->map.empty() ? 0 : _fbb.CreateString(_o->map);
  auto _window_size = _o->window_size ? _o->window_size.get() : 0;
  auto _window_pos = _o->window_pos ? _o->window_pos.get() : 0;
  auto _micro_mode = _o->micro_mode;
  return torchcraft::fbs::CreateHandshakeClient(
      _fbb,
      _protocol,
      _map,
      _window_size,
      _window_pos,
      _micro_mode);
}

inline HandshakeServerT *HandshakeServer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HandshakeServerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HandshakeServer::UnPackTo(HandshakeServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = lag_frames(); _o->lag_frames = _e; };
  { auto _e = map_size(); if (_e) _o->map_size = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = ground_height_data(); if (_e) { _o->ground_height_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ground_height_data[_i] = _e->Get(_i); } } };
  { auto _e = walkable_data(); if (_e) { _o->walkable_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->walkable_data[_i] = _e->Get(_i); } } };
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); };
  { auto _e = is_replay(); _o->is_replay = _e; };
  { auto _e = player_id(); _o->player_id = _e; };
  { auto _e = neutral_id(); _o->neutral_id = _e; };
  { auto _e = battle_frame_count(); _o->battle_frame_count = _e; };
  { auto _e = buildable_data(); if (_e) { _o->buildable_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->buildable_data[_i] = _e->Get(_i); } } };
  { auto _e = start_locations(); if (_e) { _o->start_locations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->start_locations[_i] = *_e->Get(_i); } } };
  { auto _e = players(); if (_e) { _o->players.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->players[_i] = std::unique_ptr<PlayerT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<HandshakeServer> HandshakeServer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHandshakeServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HandshakeServer> CreateHandshakeServer(flatbuffers::FlatBufferBuilder &_fbb, const HandshakeServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HandshakeServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _lag_frames = _o->lag_frames;
  auto _map_size = _o->map_size ? _o->map_size.get() : 0;
  auto _ground_height_data = _o->ground_height_data.size() ? _fbb.CreateVector(_o->ground_height_data) : 0;
  auto _walkable_data = _o->walkable_data.size() ? _fbb.CreateVector(_o->walkable_data) : 0;
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  auto _is_replay = _o->is_replay;
  auto _player_id = _o->player_id;
  auto _neutral_id = _o->neutral_id;
  auto _battle_frame_count = _o->battle_frame_count;
  auto _buildable_data = _o->buildable_data.size() ? _fbb.CreateVector(_o->buildable_data) : 0;
  auto _start_locations = _o->start_locations.size() ? _fbb.CreateVectorOfStructs(_o->start_locations) : 0;
  auto _players = _o->players.size() ? _fbb.CreateVector<flatbuffers::Offset<Player>> (_o->players.size(), [](size_t i, _VectorArgs *__va) { return CreatePlayer(*__va->__fbb, __va->__o->players[i].get(), __va->__rehasher); }, &_va ) : 0;
  return torchcraft::fbs::CreateHandshakeServer(
      _fbb,
      _lag_frames,
      _map_size,
      _ground_height_data,
      _walkable_data,
      _map_name,
      _is_replay,
      _player_id,
      _neutral_id,
      _battle_frame_count,
      _buildable_data,
      _start_locations,
      _players);
}

inline CommandsT *Commands::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CommandsT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Commands::UnPackTo(CommandsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = commands(); if (_e) { _o->commands.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->commands[_i] = std::unique_ptr<CommandT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<Commands> Commands::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CommandsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommands(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Commands> CreateCommands(flatbuffers::FlatBufferBuilder &_fbb, const CommandsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CommandsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _commands = _o->commands.size() ? _fbb.CreateVector<flatbuffers::Offset<Command>> (_o->commands.size(), [](size_t i, _VectorArgs *__va) { return CreateCommand(*__va->__fbb, __va->__o->commands[i].get(), __va->__rehasher); }, &_va ) : 0;
  return torchcraft::fbs::CreateCommands(
      _fbb,
      _commands);
}

inline FrameStateT *FrameState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FrameStateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FrameState::UnPackTo(FrameStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frameOrFrameDiff_type(); _o->frameOrFrameDiff.type = _e; };
  { auto _e = frameOrFrameDiff(); if (_e) _o->frameOrFrameDiff.value = FrameOrFrameDiffUnion::UnPack(_e, frameOrFrameDiff_type(), _resolver); };
  { auto _e = deaths(); if (_e) { _o->deaths.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->deaths[_i] = _e->Get(_i); } } };
  { auto _e = frame_from_bwapi(); _o->frame_from_bwapi = _e; };
  { auto _e = battle_frame_count(); _o->battle_frame_count = _e; };
  { auto _e = commands_status(); if (_e) { _o->commands_status.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->commands_status[_i] = _e->Get(_i); } } };
  { auto _e = img_mode(); if (_e) _o->img_mode = _e->str(); };
  { auto _e = screen_position(); if (_e) _o->screen_position = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = visibility(); if (_e) { _o->visibility.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->visibility[_i] = _e->Get(_i); } } };
  { auto _e = visibility_size(); if (_e) _o->visibility_size = std::unique_ptr<Vec2>(new Vec2(*_e)); };
  { auto _e = img_data(); if (_e) { _o->img_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->img_data[_i] = _e->Get(_i); } } };
  { auto _e = img_size(); if (_e) _o->img_size = std::unique_ptr<Vec2>(new Vec2(*_e)); };
}

inline flatbuffers::Offset<FrameState> FrameState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrameState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FrameState> CreateFrameState(flatbuffers::FlatBufferBuilder &_fbb, const FrameStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FrameStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frameOrFrameDiff_type = _o->frameOrFrameDiff.type;
  auto _frameOrFrameDiff = _o->frameOrFrameDiff.Pack(_fbb);
  auto _deaths = _o->deaths.size() ? _fbb.CreateVector(_o->deaths) : 0;
  auto _frame_from_bwapi = _o->frame_from_bwapi;
  auto _battle_frame_count = _o->battle_frame_count;
  auto _commands_status = _o->commands_status.size() ? _fbb.CreateVector(_o->commands_status) : 0;
  auto _img_mode = _o->img_mode.empty() ? 0 : _fbb.CreateString(_o->img_mode);
  auto _screen_position = _o->screen_position ? _o->screen_position.get() : 0;
  auto _visibility = _o->visibility.size() ? _fbb.CreateVector(_o->visibility) : 0;
  auto _visibility_size = _o->visibility_size ? _o->visibility_size.get() : 0;
  auto _img_data = _o->img_data.size() ? _fbb.CreateVector(_o->img_data) : 0;
  auto _img_size = _o->img_size ? _o->img_size.get() : 0;
  return torchcraft::fbs::CreateFrameState(
      _fbb,
      _frameOrFrameDiff_type,
      _frameOrFrameDiff,
      _deaths,
      _frame_from_bwapi,
      _battle_frame_count,
      _commands_status,
      _img_mode,
      _screen_position,
      _visibility,
      _visibility_size,
      _img_data,
      _img_size);
}

inline PlayerLeftT *PlayerLeft::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PlayerLeftT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PlayerLeft::UnPackTo(PlayerLeftT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player_left(); if (_e) _o->player_left = _e->str(); };
}

inline flatbuffers::Offset<PlayerLeft> PlayerLeft::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PlayerLeftT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerLeft(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PlayerLeft> CreatePlayerLeft(flatbuffers::FlatBufferBuilder &_fbb, const PlayerLeftT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PlayerLeftT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player_left = _o->player_left.empty() ? 0 : _fbb.CreateString(_o->player_left);
  return torchcraft::fbs::CreatePlayerLeft(
      _fbb,
      _player_left);
}

inline EndGameT *EndGame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EndGameT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EndGame::UnPackTo(EndGameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frameOrFrameDiff_type(); _o->frameOrFrameDiff.type = _e; };
  { auto _e = frameOrFrameDiff(); if (_e) _o->frameOrFrameDiff.value = FrameOrFrameDiffUnion::UnPack(_e, frameOrFrameDiff_type(), _resolver); };
  { auto _e = game_won(); _o->game_won = _e; };
}

inline flatbuffers::Offset<EndGame> EndGame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EndGameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEndGame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EndGame> CreateEndGame(flatbuffers::FlatBufferBuilder &_fbb, const EndGameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EndGameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frameOrFrameDiff_type = _o->frameOrFrameDiff.type;
  auto _frameOrFrameDiff = _o->frameOrFrameDiff.Pack(_fbb);
  auto _game_won = _o->game_won;
  return torchcraft::fbs::CreateEndGame(
      _fbb,
      _frameOrFrameDiff_type,
      _frameOrFrameDiff,
      _game_won);
}

inline ErrorT *Error::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ErrorT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Error::UnPackTo(ErrorT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message(); if (_e) _o->message = _e->str(); };
}

inline flatbuffers::Offset<Error> Error::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateError(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Error> CreateError(flatbuffers::FlatBufferBuilder &_fbb, const ErrorT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ErrorT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return torchcraft::fbs::CreateError(
      _fbb,
      _message);
}

inline MessageT *Message::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Message::UnPackTo(MessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg_type(); _o->msg.type = _e; };
  { auto _e = msg(); if (_e) _o->msg.value = AnyMessageUnion::UnPack(_e, msg_type(), _resolver); };
  { auto _e = uid(); if (_e) _o->uid = _e->str(); };
}

inline flatbuffers::Offset<Message> Message::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  auto _uid = _o->uid.empty() ? 0 : _fbb.CreateString(_o->uid);
  return torchcraft::fbs::CreateMessage(
      _fbb,
      _msg_type,
      _msg,
      _uid);
}

inline MapT *Map::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Map::UnPackTo(MapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = height(); _o->height = _e; };
  { auto _e = width(); _o->width = _e; };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<Map> Map::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Map> CreateMap(flatbuffers::FlatBufferBuilder &_fbb, const MapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _height = _o->height;
  auto _width = _o->width;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return torchcraft::fbs::CreateMap(
      _fbb,
      _height,
      _width,
      _data);
}

inline ActionT *Action::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ActionT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Action::UnPackTo(ActionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = action(); if (_e) { _o->action.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->action[_i] = _e->Get(_i); } } };
  { auto _e = uid(); _o->uid = _e; };
  { auto _e = aid(); _o->aid = _e; };
}

inline flatbuffers::Offset<Action> Action::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAction(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Action> CreateAction(flatbuffers::FlatBufferBuilder &_fbb, const ActionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _action = _o->action.size() ? _fbb.CreateVector(_o->action) : 0;
  auto _uid = _o->uid;
  auto _aid = _o->aid;
  return torchcraft::fbs::CreateAction(
      _fbb,
      _action,
      _uid,
      _aid);
}

inline ResourcesT *Resources::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResourcesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Resources::UnPackTo(ResourcesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ore(); _o->ore = _e; };
  { auto _e = gas(); _o->gas = _e; };
  { auto _e = used_psi(); _o->used_psi = _e; };
  { auto _e = total_psi(); _o->total_psi = _e; };
  { auto _e = upgrades(); _o->upgrades = _e; };
  { auto _e = upgrades_level(); _o->upgrades_level = _e; };
  { auto _e = techs(); _o->techs = _e; };
}

inline flatbuffers::Offset<Resources> Resources::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResources(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Resources> CreateResources(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResourcesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ore = _o->ore;
  auto _gas = _o->gas;
  auto _used_psi = _o->used_psi;
  auto _total_psi = _o->total_psi;
  auto _upgrades = _o->upgrades;
  auto _upgrades_level = _o->upgrades_level;
  auto _techs = _o->techs;
  return torchcraft::fbs::CreateResources(
      _fbb,
      _ore,
      _gas,
      _used_psi,
      _total_psi,
      _upgrades,
      _upgrades_level,
      _techs);
}

inline OrderT *Order::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new OrderT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Order::UnPackTo(OrderT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = first_frame(); _o->first_frame = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = targetId(); _o->targetId = _e; };
  { auto _e = targetX(); _o->targetX = _e; };
  { auto _e = targetY(); _o->targetY = _e; };
}

inline flatbuffers::Offset<Order> Order::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OrderT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOrder(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Order> CreateOrder(flatbuffers::FlatBufferBuilder &_fbb, const OrderT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OrderT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _first_frame = _o->first_frame;
  auto _type = _o->type;
  auto _targetId = _o->targetId;
  auto _targetX = _o->targetX;
  auto _targetY = _o->targetY;
  return torchcraft::fbs::CreateOrder(
      _fbb,
      _first_frame,
      _type,
      _targetId,
      _targetX,
      _targetY);
}

inline UnitCommandT *UnitCommand::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnitCommandT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnitCommand::UnPackTo(UnitCommandT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = targetId(); _o->targetId = _e; };
  { auto _e = targetX(); _o->targetX = _e; };
  { auto _e = targetY(); _o->targetY = _e; };
  { auto _e = extra(); _o->extra = _e; };
}

inline flatbuffers::Offset<UnitCommand> UnitCommand::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitCommandT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnitCommand(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnitCommand> CreateUnitCommand(flatbuffers::FlatBufferBuilder &_fbb, const UnitCommandT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnitCommandT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _type = _o->type;
  auto _targetId = _o->targetId;
  auto _targetX = _o->targetX;
  auto _targetY = _o->targetY;
  auto _extra = _o->extra;
  return torchcraft::fbs::CreateUnitCommand(
      _fbb,
      _frame,
      _type,
      _targetId,
      _targetX,
      _targetY,
      _extra);
}

inline BulletT *Bullet::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BulletT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Bullet::UnPackTo(BulletT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = x(); _o->x = _e; };
  { auto _e = y(); _o->y = _e; };
}

inline flatbuffers::Offset<Bullet> Bullet::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BulletT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBullet(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Bullet> CreateBullet(flatbuffers::FlatBufferBuilder &_fbb, const BulletT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BulletT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _x = _o->x;
  auto _y = _o->y;
  return torchcraft::fbs::CreateBullet(
      _fbb,
      _type,
      _x,
      _y);
}

inline UnitT *Unit::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnitT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Unit::UnPackTo(UnitT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = x(); _o->x = _e; };
  { auto _e = y(); _o->y = _e; };
  { auto _e = health(); _o->health = _e; };
  { auto _e = max_health(); _o->max_health = _e; };
  { auto _e = shield(); _o->shield = _e; };
  { auto _e = max_shield(); _o->max_shield = _e; };
  { auto _e = energy(); _o->energy = _e; };
  { auto _e = maxCD(); _o->maxCD = _e; };
  { auto _e = groundCD(); _o->groundCD = _e; };
  { auto _e = airCD(); _o->airCD = _e; };
  { auto _e = flags(); _o->flags = _e; };
  { auto _e = visible(); _o->visible = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = armor(); _o->armor = _e; };
  { auto _e = shieldArmor(); _o->shieldArmor = _e; };
  { auto _e = size(); _o->size = _e; };
  { auto _e = pixel_x(); _o->pixel_x = _e; };
  { auto _e = pixel_y(); _o->pixel_y = _e; };
  { auto _e = pixel_size_x(); _o->pixel_size_x = _e; };
  { auto _e = pixel_size_y(); _o->pixel_size_y = _e; };
  { auto _e = groundATK(); _o->groundATK = _e; };
  { auto _e = airATK(); _o->airATK = _e; };
  { auto _e = groundDmgType(); _o->groundDmgType = _e; };
  { auto _e = airDmgType(); _o->airDmgType = _e; };
  { auto _e = groundRange(); _o->groundRange = _e; };
  { auto _e = airRange(); _o->airRange = _e; };
  { auto _e = orders(); if (_e) { _o->orders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->orders[_i] = std::unique_ptr<OrderT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = command(); if (_e) _o->command = std::unique_ptr<UnitCommandT>(_e->UnPack(_resolver)); };
  { auto _e = velocityX(); _o->velocityX = _e; };
  { auto _e = velocityY(); _o->velocityY = _e; };
  { auto _e = playerId(); _o->playerId = _e; };
  { auto _e = resources(); _o->resources = _e; };
  { auto _e = buildTechUpgradeType(); _o->buildTechUpgradeType = _e; };
  { auto _e = remainingBuildTrainTime(); _o->remainingBuildTrainTime = _e; };
  { auto _e = remainingUpgradeResearchTime(); _o->remainingUpgradeResearchTime = _e; };
  { auto _e = spellCD(); _o->spellCD = _e; };
  { auto _e = associatedUnit(); _o->associatedUnit = _e; };
  { auto _e = associatedCount(); _o->associatedCount = _e; };
}

inline flatbuffers::Offset<Unit> Unit::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnit(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Unit> CreateUnit(flatbuffers::FlatBufferBuilder &_fbb, const UnitT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnitT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _health = _o->health;
  auto _max_health = _o->max_health;
  auto _shield = _o->shield;
  auto _max_shield = _o->max_shield;
  auto _energy = _o->energy;
  auto _maxCD = _o->maxCD;
  auto _groundCD = _o->groundCD;
  auto _airCD = _o->airCD;
  auto _flags = _o->flags;
  auto _visible = _o->visible;
  auto _type = _o->type;
  auto _armor = _o->armor;
  auto _shieldArmor = _o->shieldArmor;
  auto _size = _o->size;
  auto _pixel_x = _o->pixel_x;
  auto _pixel_y = _o->pixel_y;
  auto _pixel_size_x = _o->pixel_size_x;
  auto _pixel_size_y = _o->pixel_size_y;
  auto _groundATK = _o->groundATK;
  auto _airATK = _o->airATK;
  auto _groundDmgType = _o->groundDmgType;
  auto _airDmgType = _o->airDmgType;
  auto _groundRange = _o->groundRange;
  auto _airRange = _o->airRange;
  auto _orders = _o->orders.size() ? _fbb.CreateVector<flatbuffers::Offset<Order>> (_o->orders.size(), [](size_t i, _VectorArgs *__va) { return CreateOrder(*__va->__fbb, __va->__o->orders[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _command = _o->command ? CreateUnitCommand(_fbb, _o->command.get(), _rehasher) : 0;
  auto _velocityX = _o->velocityX;
  auto _velocityY = _o->velocityY;
  auto _playerId = _o->playerId;
  auto _resources = _o->resources;
  auto _buildTechUpgradeType = _o->buildTechUpgradeType;
  auto _remainingBuildTrainTime = _o->remainingBuildTrainTime;
  auto _remainingUpgradeResearchTime = _o->remainingUpgradeResearchTime;
  auto _spellCD = _o->spellCD;
  auto _associatedUnit = _o->associatedUnit;
  auto _associatedCount = _o->associatedCount;
  return torchcraft::fbs::CreateUnit(
      _fbb,
      _id,
      _x,
      _y,
      _health,
      _max_health,
      _shield,
      _max_shield,
      _energy,
      _maxCD,
      _groundCD,
      _airCD,
      _flags,
      _visible,
      _type,
      _armor,
      _shieldArmor,
      _size,
      _pixel_x,
      _pixel_y,
      _pixel_size_x,
      _pixel_size_y,
      _groundATK,
      _airATK,
      _groundDmgType,
      _airDmgType,
      _groundRange,
      _airRange,
      _orders,
      _command,
      _velocityX,
      _velocityY,
      _playerId,
      _resources,
      _buildTechUpgradeType,
      _remainingBuildTrainTime,
      _remainingUpgradeResearchTime,
      _spellCD,
      _associatedUnit,
      _associatedCount);
}

inline UnitsByPlayerIdT *UnitsByPlayerId::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnitsByPlayerIdT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnitsByPlayerId::UnPackTo(UnitsByPlayerIdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = playerId(); _o->playerId = _e; };
  { auto _e = units(); if (_e) { _o->units.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->units[_i] = std::unique_ptr<UnitT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<UnitsByPlayerId> UnitsByPlayerId::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitsByPlayerIdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnitsByPlayerId(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnitsByPlayerId> CreateUnitsByPlayerId(flatbuffers::FlatBufferBuilder &_fbb, const UnitsByPlayerIdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnitsByPlayerIdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _playerId = _o->playerId;
  auto _units = _o->units.size() ? _fbb.CreateVector<flatbuffers::Offset<Unit>> (_o->units.size(), [](size_t i, _VectorArgs *__va) { return CreateUnit(*__va->__fbb, __va->__o->units[i].get(), __va->__rehasher); }, &_va ) : 0;
  return torchcraft::fbs::CreateUnitsByPlayerId(
      _fbb,
      _playerId,
      _units);
}

inline ActionsByPlayerIdT *ActionsByPlayerId::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ActionsByPlayerIdT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ActionsByPlayerId::UnPackTo(ActionsByPlayerIdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = playerId(); _o->playerId = _e; };
  { auto _e = actions(); if (_e) { _o->actions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actions[_i] = std::unique_ptr<ActionT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ActionsByPlayerId> ActionsByPlayerId::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ActionsByPlayerIdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateActionsByPlayerId(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ActionsByPlayerId> CreateActionsByPlayerId(flatbuffers::FlatBufferBuilder &_fbb, const ActionsByPlayerIdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ActionsByPlayerIdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _playerId = _o->playerId;
  auto _actions = _o->actions.size() ? _fbb.CreateVector<flatbuffers::Offset<Action>> (_o->actions.size(), [](size_t i, _VectorArgs *__va) { return CreateAction(*__va->__fbb, __va->__o->actions[i].get(), __va->__rehasher); }, &_va ) : 0;
  return torchcraft::fbs::CreateActionsByPlayerId(
      _fbb,
      _playerId,
      _actions);
}

inline ResourcesByPlayerIdT *ResourcesByPlayerId::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ResourcesByPlayerIdT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ResourcesByPlayerId::UnPackTo(ResourcesByPlayerIdT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = playerId(); _o->playerId = _e; };
  { auto _e = resources(); if (_e) _o->resources = std::unique_ptr<ResourcesT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ResourcesByPlayerId> ResourcesByPlayerId::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesByPlayerIdT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateResourcesByPlayerId(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ResourcesByPlayerId> CreateResourcesByPlayerId(flatbuffers::FlatBufferBuilder &_fbb, const ResourcesByPlayerIdT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ResourcesByPlayerIdT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _playerId = _o->playerId;
  auto _resources = _o->resources ? CreateResources(_fbb, _o->resources.get(), _rehasher) : 0;
  return torchcraft::fbs::CreateResourcesByPlayerId(
      _fbb,
      _playerId,
      _resources);
}

inline FrameT *Frame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FrameT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Frame::UnPackTo(FrameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = units(); if (_e) { _o->units.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->units[_i] = std::unique_ptr<UnitsByPlayerIdT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = actions(); if (_e) { _o->actions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actions[_i] = std::unique_ptr<ActionsByPlayerIdT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = resources(); if (_e) { _o->resources.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->resources[_i] = std::unique_ptr<ResourcesByPlayerIdT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = bullets(); if (_e) { _o->bullets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bullets[_i] = std::unique_ptr<BulletT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = creep_map(); if (_e) { _o->creep_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->creep_map[_i] = _e->Get(_i); } } };
  { auto _e = width(); _o->width = _e; };
  { auto _e = height(); _o->height = _e; };
  { auto _e = reward(); _o->reward = _e; };
  { auto _e = is_terminal(); _o->is_terminal = _e; };
}

inline flatbuffers::Offset<Frame> Frame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Frame> CreateFrame(flatbuffers::FlatBufferBuilder &_fbb, const FrameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FrameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _units = _o->units.size() ? _fbb.CreateVector<flatbuffers::Offset<UnitsByPlayerId>> (_o->units.size(), [](size_t i, _VectorArgs *__va) { return CreateUnitsByPlayerId(*__va->__fbb, __va->__o->units[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _actions = _o->actions.size() ? _fbb.CreateVector<flatbuffers::Offset<ActionsByPlayerId>> (_o->actions.size(), [](size_t i, _VectorArgs *__va) { return CreateActionsByPlayerId(*__va->__fbb, __va->__o->actions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _resources = _o->resources.size() ? _fbb.CreateVector<flatbuffers::Offset<ResourcesByPlayerId>> (_o->resources.size(), [](size_t i, _VectorArgs *__va) { return CreateResourcesByPlayerId(*__va->__fbb, __va->__o->resources[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _bullets = _o->bullets.size() ? _fbb.CreateVector<flatbuffers::Offset<Bullet>> (_o->bullets.size(), [](size_t i, _VectorArgs *__va) { return CreateBullet(*__va->__fbb, __va->__o->bullets[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _creep_map = _o->creep_map.size() ? _fbb.CreateVector(_o->creep_map) : 0;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _reward = _o->reward;
  auto _is_terminal = _o->is_terminal;
  return torchcraft::fbs::CreateFrame(
      _fbb,
      _units,
      _actions,
      _resources,
      _bullets,
      _creep_map,
      _width,
      _height,
      _reward,
      _is_terminal);
}

inline UnitDiffT *UnitDiff::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnitDiffT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnitDiff::UnPackTo(UnitDiffT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = var_ids(); if (_e) { _o->var_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->var_ids[_i] = _e->Get(_i); } } };
  { auto _e = var_diffs(); if (_e) { _o->var_diffs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->var_diffs[_i] = _e->Get(_i); } } };
  { auto _e = order_ids(); if (_e) { _o->order_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->order_ids[_i] = _e->Get(_i); } } };
  { auto _e = order_diffs(); if (_e) { _o->order_diffs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->order_diffs[_i] = _e->Get(_i); } } };
  { auto _e = order_size(); _o->order_size = _e; };
  { auto _e = velocityX(); _o->velocityX = _e; };
  { auto _e = velocityY(); _o->velocityY = _e; };
  { auto _e = flags(); _o->flags = _e; };
}

inline flatbuffers::Offset<UnitDiff> UnitDiff::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitDiffT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnitDiff(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnitDiff> CreateUnitDiff(flatbuffers::FlatBufferBuilder &_fbb, const UnitDiffT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnitDiffT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _var_ids = _o->var_ids.size() ? _fbb.CreateVector(_o->var_ids) : 0;
  auto _var_diffs = _o->var_diffs.size() ? _fbb.CreateVector(_o->var_diffs) : 0;
  auto _order_ids = _o->order_ids.size() ? _fbb.CreateVector(_o->order_ids) : 0;
  auto _order_diffs = _o->order_diffs.size() ? _fbb.CreateVector(_o->order_diffs) : 0;
  auto _order_size = _o->order_size;
  auto _velocityX = _o->velocityX;
  auto _velocityY = _o->velocityY;
  auto _flags = _o->flags;
  return torchcraft::fbs::CreateUnitDiff(
      _fbb,
      _id,
      _var_ids,
      _var_diffs,
      _order_ids,
      _order_diffs,
      _order_size,
      _velocityX,
      _velocityY,
      _flags);
}

inline UnitDiffContainerT *UnitDiffContainer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnitDiffContainerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnitDiffContainer::UnPackTo(UnitDiffContainerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = units(); if (_e) { _o->units.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->units[_i] = std::unique_ptr<UnitDiffT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<UnitDiffContainer> UnitDiffContainer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitDiffContainerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnitDiffContainer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnitDiffContainer> CreateUnitDiffContainer(flatbuffers::FlatBufferBuilder &_fbb, const UnitDiffContainerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnitDiffContainerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _units = _o->units.size() ? _fbb.CreateVector<flatbuffers::Offset<UnitDiff>> (_o->units.size(), [](size_t i, _VectorArgs *__va) { return CreateUnitDiff(*__va->__fbb, __va->__o->units[i].get(), __va->__rehasher); }, &_va ) : 0;
  return torchcraft::fbs::CreateUnitDiffContainer(
      _fbb,
      _units);
}

inline FrameDiffCreepT *FrameDiffCreep::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FrameDiffCreepT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FrameDiffCreep::UnPackTo(FrameDiffCreepT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; };
  { auto _e = creep(); _o->creep = _e; };
}

inline flatbuffers::Offset<FrameDiffCreep> FrameDiffCreep::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameDiffCreepT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrameDiffCreep(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FrameDiffCreep> CreateFrameDiffCreep(flatbuffers::FlatBufferBuilder &_fbb, const FrameDiffCreepT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FrameDiffCreepT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _creep = _o->creep;
  return torchcraft::fbs::CreateFrameDiffCreep(
      _fbb,
      _index,
      _creep);
}

inline FrameDiffT *FrameDiff::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FrameDiffT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FrameDiff::UnPackTo(FrameDiffT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pids(); if (_e) { _o->pids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pids[_i] = _e->Get(_i); } } };
  { auto _e = unitDiffContainers(); if (_e) { _o->unitDiffContainers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->unitDiffContainers[_i] = std::unique_ptr<UnitDiffContainerT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = actions(); if (_e) { _o->actions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actions[_i] = std::unique_ptr<ActionsByPlayerIdT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = resources(); if (_e) { _o->resources.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->resources[_i] = std::unique_ptr<ResourcesByPlayerIdT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = bullets(); if (_e) { _o->bullets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->bullets[_i] = std::unique_ptr<BulletT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = creep_map(); if (_e) { _o->creep_map.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->creep_map[_i] = std::unique_ptr<FrameDiffCreepT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = reward(); _o->reward = _e; };
  { auto _e = is_terminal(); _o->is_terminal = _e; };
}

inline flatbuffers::Offset<FrameDiff> FrameDiff::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameDiffT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrameDiff(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FrameDiff> CreateFrameDiff(flatbuffers::FlatBufferBuilder &_fbb, const FrameDiffT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FrameDiffT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pids = _o->pids.size() ? _fbb.CreateVector(_o->pids) : 0;
  auto _unitDiffContainers = _o->unitDiffContainers.size() ? _fbb.CreateVector<flatbuffers::Offset<UnitDiffContainer>> (_o->unitDiffContainers.size(), [](size_t i, _VectorArgs *__va) { return CreateUnitDiffContainer(*__va->__fbb, __va->__o->unitDiffContainers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _actions = _o->actions.size() ? _fbb.CreateVector<flatbuffers::Offset<ActionsByPlayerId>> (_o->actions.size(), [](size_t i, _VectorArgs *__va) { return CreateActionsByPlayerId(*__va->__fbb, __va->__o->actions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _resources = _o->resources.size() ? _fbb.CreateVector<flatbuffers::Offset<ResourcesByPlayerId>> (_o->resources.size(), [](size_t i, _VectorArgs *__va) { return CreateResourcesByPlayerId(*__va->__fbb, __va->__o->resources[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _bullets = _o->bullets.size() ? _fbb.CreateVector<flatbuffers::Offset<Bullet>> (_o->bullets.size(), [](size_t i, _VectorArgs *__va) { return CreateBullet(*__va->__fbb, __va->__o->bullets[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _creep_map = _o->creep_map.size() ? _fbb.CreateVector<flatbuffers::Offset<FrameDiffCreep>> (_o->creep_map.size(), [](size_t i, _VectorArgs *__va) { return CreateFrameDiffCreep(*__va->__fbb, __va->__o->creep_map[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _reward = _o->reward;
  auto _is_terminal = _o->is_terminal;
  return torchcraft::fbs::CreateFrameDiff(
      _fbb,
      _pids,
      _unitDiffContainers,
      _actions,
      _resources,
      _bullets,
      _creep_map,
      _reward,
      _is_terminal);
}

inline UnitCountT *UnitCount::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UnitCountT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UnitCount::UnPackTo(UnitCountT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = a(); _o->a = _e; };
  { auto _e = b(); _o->b = _e; };
}

inline flatbuffers::Offset<UnitCount> UnitCount::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UnitCountT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUnitCount(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UnitCount> CreateUnitCount(flatbuffers::FlatBufferBuilder &_fbb, const UnitCountT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UnitCountT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _a = _o->a;
  auto _b = _o->b;
  return torchcraft::fbs::CreateUnitCount(
      _fbb,
      _a,
      _b);
}

inline ReplayerT *Replayer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ReplayerT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Replayer::UnPackTo(ReplayerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frames(); if (_e) { _o->frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->frames[_i] = std::unique_ptr<FrameT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = numUnits(); if (_e) { _o->numUnits.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->numUnits[_i] = std::unique_ptr<UnitCountT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = map(); if (_e) _o->map = std::unique_ptr<MapT>(_e->UnPack(_resolver)); };
  { auto _e = keyFrame(); _o->keyFrame = _e; };
}

inline flatbuffers::Offset<Replayer> Replayer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReplayerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReplayer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Replayer> CreateReplayer(flatbuffers::FlatBufferBuilder &_fbb, const ReplayerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReplayerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frames = _o->frames.size() ? _fbb.CreateVector<flatbuffers::Offset<Frame>> (_o->frames.size(), [](size_t i, _VectorArgs *__va) { return CreateFrame(*__va->__fbb, __va->__o->frames[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _numUnits = _o->numUnits.size() ? _fbb.CreateVector<flatbuffers::Offset<UnitCount>> (_o->numUnits.size(), [](size_t i, _VectorArgs *__va) { return CreateUnitCount(*__va->__fbb, __va->__o->numUnits[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _map = _o->map ? CreateMap(_fbb, _o->map.get(), _rehasher) : 0;
  auto _keyFrame = _o->keyFrame;
  return torchcraft::fbs::CreateReplayer(
      _fbb,
      _frames,
      _numUnits,
      _map,
      _keyFrame);
}

inline bool VerifyFrameOrFrameDiff(flatbuffers::Verifier &verifier, const void *obj, FrameOrFrameDiff type) {
  switch (type) {
    case FrameOrFrameDiff::NONE: {
      return true;
    }
    case FrameOrFrameDiff::Frame: {
      auto ptr = reinterpret_cast<const Frame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FrameOrFrameDiff::FrameDiff: {
      auto ptr = reinterpret_cast<const FrameDiff *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyFrameOrFrameDiffVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFrameOrFrameDiff(
        verifier,  values->Get(i), types->GetEnum<FrameOrFrameDiff>(i))) {
      return false;
    }
  }
  return true;
}

inline void *FrameOrFrameDiffUnion::UnPack(const void *obj, FrameOrFrameDiff type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case FrameOrFrameDiff::Frame: {
      auto ptr = reinterpret_cast<const Frame *>(obj);
      return ptr->UnPack(resolver);
    }
    case FrameOrFrameDiff::FrameDiff: {
      auto ptr = reinterpret_cast<const FrameDiff *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> FrameOrFrameDiffUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case FrameOrFrameDiff::Frame: {
      auto ptr = reinterpret_cast<const FrameT *>(value);
      return CreateFrame(_fbb, ptr, _rehasher).Union();
    }
    case FrameOrFrameDiff::FrameDiff: {
      auto ptr = reinterpret_cast<const FrameDiffT *>(value);
      return CreateFrameDiff(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline FrameOrFrameDiffUnion::FrameOrFrameDiffUnion(const FrameOrFrameDiffUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case FrameOrFrameDiff::Frame: {
      assert(false);  // FrameT not copyable.
      break;
    }
    case FrameOrFrameDiff::FrameDiff: {
      assert(false);  // FrameDiffT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void FrameOrFrameDiffUnion::Reset() {
  switch (type) {
    case FrameOrFrameDiff::Frame: {
      auto ptr = reinterpret_cast<FrameT *>(value);
      delete ptr;
      break;
    }
    case FrameOrFrameDiff::FrameDiff: {
      auto ptr = reinterpret_cast<FrameDiffT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = FrameOrFrameDiff::NONE;
}

inline bool VerifyAnyMessage(flatbuffers::Verifier &verifier, const void *obj, AnyMessage type) {
  switch (type) {
    case AnyMessage::NONE: {
      return true;
    }
    case AnyMessage::HandshakeClient: {
      auto ptr = reinterpret_cast<const HandshakeClient *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessage::Commands: {
      auto ptr = reinterpret_cast<const Commands *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessage::HandshakeServer: {
      auto ptr = reinterpret_cast<const HandshakeServer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessage::FrameState: {
      auto ptr = reinterpret_cast<const FrameState *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessage::PlayerLeft: {
      auto ptr = reinterpret_cast<const PlayerLeft *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessage::EndGame: {
      auto ptr = reinterpret_cast<const EndGame *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyMessage::Error: {
      auto ptr = reinterpret_cast<const Error *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyMessage(
        verifier,  values->Get(i), types->GetEnum<AnyMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AnyMessageUnion::UnPack(const void *obj, AnyMessage type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case AnyMessage::HandshakeClient: {
      auto ptr = reinterpret_cast<const HandshakeClient *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyMessage::Commands: {
      auto ptr = reinterpret_cast<const Commands *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyMessage::HandshakeServer: {
      auto ptr = reinterpret_cast<const HandshakeServer *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyMessage::FrameState: {
      auto ptr = reinterpret_cast<const FrameState *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyMessage::PlayerLeft: {
      auto ptr = reinterpret_cast<const PlayerLeft *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyMessage::EndGame: {
      auto ptr = reinterpret_cast<const EndGame *>(obj);
      return ptr->UnPack(resolver);
    }
    case AnyMessage::Error: {
      auto ptr = reinterpret_cast<const Error *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> AnyMessageUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case AnyMessage::HandshakeClient: {
      auto ptr = reinterpret_cast<const HandshakeClientT *>(value);
      return CreateHandshakeClient(_fbb, ptr, _rehasher).Union();
    }
    case AnyMessage::Commands: {
      auto ptr = reinterpret_cast<const CommandsT *>(value);
      return CreateCommands(_fbb, ptr, _rehasher).Union();
    }
    case AnyMessage::HandshakeServer: {
      auto ptr = reinterpret_cast<const HandshakeServerT *>(value);
      return CreateHandshakeServer(_fbb, ptr, _rehasher).Union();
    }
    case AnyMessage::FrameState: {
      auto ptr = reinterpret_cast<const FrameStateT *>(value);
      return CreateFrameState(_fbb, ptr, _rehasher).Union();
    }
    case AnyMessage::PlayerLeft: {
      auto ptr = reinterpret_cast<const PlayerLeftT *>(value);
      return CreatePlayerLeft(_fbb, ptr, _rehasher).Union();
    }
    case AnyMessage::EndGame: {
      auto ptr = reinterpret_cast<const EndGameT *>(value);
      return CreateEndGame(_fbb, ptr, _rehasher).Union();
    }
    case AnyMessage::Error: {
      auto ptr = reinterpret_cast<const ErrorT *>(value);
      return CreateError(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AnyMessageUnion::AnyMessageUnion(const AnyMessageUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case AnyMessage::HandshakeClient: {
      assert(false);  // HandshakeClientT not copyable.
      break;
    }
    case AnyMessage::Commands: {
      assert(false);  // CommandsT not copyable.
      break;
    }
    case AnyMessage::HandshakeServer: {
      assert(false);  // HandshakeServerT not copyable.
      break;
    }
    case AnyMessage::FrameState: {
      assert(false);  // FrameStateT not copyable.
      break;
    }
    case AnyMessage::PlayerLeft: {
      value = new PlayerLeftT(*reinterpret_cast<PlayerLeftT *>(u.value));
      break;
    }
    case AnyMessage::EndGame: {
      value = new EndGameT(*reinterpret_cast<EndGameT *>(u.value));
      break;
    }
    case AnyMessage::Error: {
      value = new ErrorT(*reinterpret_cast<ErrorT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void AnyMessageUnion::Reset() {
  switch (type) {
    case AnyMessage::HandshakeClient: {
      auto ptr = reinterpret_cast<HandshakeClientT *>(value);
      delete ptr;
      break;
    }
    case AnyMessage::Commands: {
      auto ptr = reinterpret_cast<CommandsT *>(value);
      delete ptr;
      break;
    }
    case AnyMessage::HandshakeServer: {
      auto ptr = reinterpret_cast<HandshakeServerT *>(value);
      delete ptr;
      break;
    }
    case AnyMessage::FrameState: {
      auto ptr = reinterpret_cast<FrameStateT *>(value);
      delete ptr;
      break;
    }
    case AnyMessage::PlayerLeft: {
      auto ptr = reinterpret_cast<PlayerLeftT *>(value);
      delete ptr;
      break;
    }
    case AnyMessage::EndGame: {
      auto ptr = reinterpret_cast<EndGameT *>(value);
      delete ptr;
      break;
    }
    case AnyMessage::Error: {
      auto ptr = reinterpret_cast<ErrorT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AnyMessage::NONE;
}

inline const torchcraft::fbs::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<torchcraft::fbs::Message>(buf);
}

inline Message *GetMutableMessage(void *buf) {
  return flatbuffers::GetMutableRoot<Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<torchcraft::fbs::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<torchcraft::fbs::Message> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<MessageT> UnPackMessage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MessageT>(GetMessage(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace torchcraft

#endif  // FLATBUFFERS_GENERATED_TORCHCRAFT_TORCHCRAFT_FBS_H_
